# Intuition
![[../../../../Pasted image 20260202140324.png]]
# Drafts:
## Draft1: ArrayList add/remove problem (Python and Java are different)
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum3(int k, int n) {

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

  

Â  Â  Â  Â  helper(k,n,0,1,0,res,work);

Â  Â  Â  Â  /*

Â  Â  Â  Â  k -> max elements allowed in List

Â  Â  Â  Â  n -> target sum

Â  Â  Â  Â  sum = 0 -> tracks sum of List

Â  Â  Â  Â  i = 1 -> tracks which num goes in next

Â  Â  Â  Â  sz = 0 -> tracks sz of List ( i can use .size() but idk it feels faster)

Â  Â  Â  Â  res -> stores the results ( stores copy of work / snapshot )

Â  Â  Â  Â  work -> buffer or working List (mutable)

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  boolean helper(int k, int n, int sum, int i, int sz, List<List<Integer>> res, List<Integer> work){

  

Â  Â  Â  Â  // Guard the i (nah guard it in for loop below no need seperate checking)

Â  Â  Â  Â  // Guard the k

Â  Â  Â  Â  if(sz > k){

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check the sum

Â  Â  Â  Â  if( sum >= n){

Â  Â  Â  Â  Â  Â  if(sum == n){

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<Integer>(work));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Just 0 to 9 only

Â  Â  Â  Â  while(i < 10){

  

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(i);

  

Â  Â  Â  Â  Â  Â  // Recurse

Â  Â  Â  Â  Â  Â  boolean subProblem = helper(k,n, sum+i, i+1, sz+1, res, work);

  

Â  Â  Â  Â  Â  Â  // Not Pick

Â  Â  Â  Â  Â  Â  work.remove(i);

  

Â  Â  Â  Â  Â  Â  // Im pruning at the end cus, idk for some reason it feels right to do it at last

Â  Â  Â  Â  Â  Â  // Or else recursion doesnt get reset, Pick and Not Pick should happen properly

Â  Â  Â  Â  Â  Â  if(subProblem == false){

Â  Â  Â  Â  Â  Â  Â  Â  // You can't go to next Iteration so go back to mama call

Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  // Next State

Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  }

Â  Â  Â  Â  // You can't iterate more than 9

Â  Â  Â  Â  return false;

Â  Â  }

}
```

```java
java.lang.IndexOutOfBoundsException: Index 4 out of bounds for length 4 at line 100, java.base/jdk.internal.util.Preconditions.outOfBounds at line 106, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex at line 302, java.base/jdk.internal.util.Preconditions.checkIndex at line 365, java.base/java.util.Objects.checkIndex at line 552, java.base/java.util.ArrayList.remove at line 46, Solution.helper at line 43, Solution.helper at line 43, Solution.helper at line 43, Solution.helper at line 6, Solution.combinationSum3 at line 56, __DriverSolution__.__helper__ at line 89, __Driver__.main
```

## Draft2: I forgot about k while solving n ( Btw manual size tracking is unreliable avoid it minor optimisation bad compared to durablity)
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum3(int k, int n) {

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

  

Â  Â  Â  Â  helper(k,n,0,1,0,res,work);

Â  Â  Â  Â  /*

Â  Â  Â  Â  k -> max elements allowed in List

Â  Â  Â  Â  n -> target sum

Â  Â  Â  Â  sum = 0 -> tracks sum of List

Â  Â  Â  Â  i = 1 -> tracks which num goes in next

Â  Â  Â  Â  sz = 0 -> tracks sz of List ( i can use .size() but idk it feels faster)

Â  Â  Â  Â  res -> stores the results ( stores copy of work / snapshot )

Â  Â  Â  Â  work -> buffer or working List (mutable)

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  boolean helper(int k, int n, int sum, int i, int sz, List<List<Integer>> res, List<Integer> work){

  

Â  Â  Â  Â  // Guard the i (nah guard it in for loop below no need seperate checking)

Â  Â  Â  Â  // Guard the k

Â  Â  Â  Â  if(sz > k){

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check the sum

Â  Â  Â  Â  if( sum >= n){

Â  Â  Â  Â  Â  Â  if(sum == n){

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<Integer>(work));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Just 0 to 9 only

Â  Â  Â  Â  while(i < 10){

  

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(i);

  

Â  Â  Â  Â  Â  Â  // Recurse

Â  Â  Â  Â  Â  Â  boolean subProblem = helper(k,n, sum+i, i+1, sz+1, res, work);

  

Â  Â  Â  Â  Â  Â  // Not Pick

Â  Â  Â  Â  Â  Â  work.remove(work.size() - 1);

  

Â  Â  Â  Â  Â  Â  // Im pruning at the end cus, idk for some reason it feels right to do it at last

Â  Â  Â  Â  Â  Â  // Or else recursion doesnt get reset, Pick and Not Pick should happen properly

Â  Â  Â  Â  Â  Â  if(subProblem == false){

Â  Â  Â  Â  Â  Â  Â  Â  // You can't go to next Iteration so go back to mama call

Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  // Next State

Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  }

Â  Â  Â  Â  // You can't iterate more than 9

Â  Â  Â  Â  return false;

Â  Â  }

}

```
```java
Wrong Answer

Runtime: 0 ms

Case 1

Case 2

Case 3

Input

kÂ =

3

nÂ =

7

Output

[[1,2,4],[1,6],[2,5],[3,4],[7]]

Expected

[[1,2,4]]
```
# Code:
## My Code:
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum3(int k, int n) {

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

  

Â  Â  Â  Â  helper(k,n,0,1,0,res,work);

Â  Â  Â  Â  /*

Â  Â  Â  Â  k -> max elements allowed in List

Â  Â  Â  Â  n -> target sum

Â  Â  Â  Â  sum = 0 -> tracks sum of List

Â  Â  Â  Â  i = 1 -> tracks which num goes in next

Â  Â  Â  Â  sz = 0 -> tracks sz of List ( i can use .size() but idk it feels faster)

Â  Â  Â  Â  res -> stores the results ( stores copy of work / snapshot )

Â  Â  Â  Â  work -> buffer or working List (mutable)

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  boolean helper(int k, int n, int sum, int i, int sz, List<List<Integer>> res, List<Integer> work){

  

Â  Â  Â  Â  // Guard the i (nah guard it in for loop below no need seperate checking)

Â  Â  Â  Â  // Guard the k

Â  Â  Â  Â  if(sz > k){

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check the sum

Â  Â  Â  Â  if( sum >= n){

Â  Â  Â  Â  Â  Â  if(sum == n && sz==k){

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<Integer>(work));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return false;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Just 0 to 9 only

Â  Â  Â  Â  while(i < 10){

  

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(i);

  

Â  Â  Â  Â  Â  Â  // Recurse

Â  Â  Â  Â  Â  Â  boolean subProblem = helper(k,n, sum+i, i+1, sz+1, res, work);

  

Â  Â  Â  Â  Â  Â  // Not Pick

Â  Â  Â  Â  Â  Â  work.remove(work.size() - 1);

  

Â  Â  Â  Â  Â  Â  // Im pruning at the end cus, idk for some reason it feels right to do it at last

Â  Â  Â  Â  Â  Â  // Or else recursion doesnt get reset, Pick and Not Pick should happen properly

Â  Â  Â  Â  Â  Â  if(subProblem == false){

Â  Â  Â  Â  Â  Â  Â  Â  // You can't go to next Iteration so go back to mama call

Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  // Next State

Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  }

Â  Â  Â  Â  // You can't iterate more than 9

Â  Â  Â  Â  return false;

Â  Â  }

}
```

## ðŸŸ  Learning Summary â€” Combination Sum III (From _Your_ Comments & Intuition Only)

---

## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ðŸ§  1ï¸âƒ£ Mental Model vs Memorization

**Your starting instinct (visible from comments):**

- â€œThis is small: numbers 1â€“9, just recurseâ€
    
- â€œIf something fails, I should be able to stop earlyâ€
    
- â€œSum is monotonic, index is monotonic â†’ pruning should workâ€
    

That instinct is **reasonable**.  
The search space _looks_ linear-ish because:

- `i` only increases
    
- `sum` only increases
    
- numbers are bounded
    

So the natural mental leap is:

> â€œOnce a subcall fails, nothing later will work either.â€

**Where this mental model quietly breaks (without you noticing):**

- Failure here is **not absolute**
    
- It depends on **how many slots are left** (`k - sz`)
    

A branch can fail because:

- it used _too few_ numbers
    
- or _too many_
    
- or hit sum early with wrong size
    

That failure says **nothing** about siblings at the same depth.

The key shift is very small:

> Recursion here is not answering â€œcan this work?â€  
> It is **describing all valid states that satisfy coupled constraints**.

Once you see that, boolean â€œsuccess / failureâ€ starts feeling out of place â€” not wrong, just mismatched.

---

### ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

Itâ€™s tempting to label this as:

- backtracking
    
- DFS
    
- recursion with pruning
    

Those labels arenâ€™t helping much.

From your comments, the real structure is:

- Fixed domain: `1..9`
    
- Strictly increasing choices (`i`)
    
- Exact **shape constraint** (`sz == k`)
    
- Exact **value constraint** (`sum == n`)
    

This is not:

- subset-sum (decision)
    
- path existence
    
- â€œfind one valid answerâ€
    

It is:

> **Enumerate all states that satisfy multiple invariants at the same time**

Once you classify it that way, tools fade and invariants take over.

---

### ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

_(Explained directly from your comment lines)_

---

#### ðŸ’¬ `k -> max elements allowed in List`

What this comment is protecting you from:

- Treating `k` as a _limit_ instead of a **requirement**
    

Why forgetting it felt natural (Draft2):

- Sum feels like the â€œreal goalâ€
    
- Size feels secondary
    

But the problem demands:

- `sum == n` **AND**
    
- `sz == k`
    

Without enforcing both together, `[1,6]`, `[7]`, `[2,5]` slip through â€” exactly what you observed.

---

#### ðŸ’¬ `sz = 0 -> tracks sz of List (i can use .size() but idk it feels faster)`

This comment reveals two thoughts:

- performance awareness
    
- control over state
    

What actually matters here:

- `work.size()` is already O(1)
    
- manual `sz` introduces **state duplication**
    

Why it becomes unreliable:

- now you must keep `sz` and `work` perfectly in sync
    
- recursion + early returns increase desync risk
    

Your own later note (â€œavoid it, minor optimisationâ€) is the correct realization.

---

#### ðŸ’¬ `i = 1 -> tracks which num goes in next`

This is the **strongest invariant in your solution**.

What it prevents:

- duplicates
    
- permutations
    
- reuse of numbers
    

Why guarding `i` in the loop (not separately) feels right:

- it keeps **state evolution linear**
    
- fewer mental branches to track
    

This part of your thinking is solid.

---

#### ðŸ’¬ `work -> buffer or working List (mutable)`

This shows you understood:

- mutation is intentional
    
- snapshots are taken only at success
    

Thatâ€™s why:

```java
res.add(new ArrayList<>(work));
```

exists â€” not as syntax, but as **state freezing**.

---

### ðŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why Your Drafts Matter

---

#### ðŸ§¾ Draft1 â€” `ArrayList add/remove problem`

Your comment:

> â€œPython and Java are differentâ€

Exactly.

What confusion this prevents:

- assuming â€œremove what I addedâ€ works by value
    

Why the bug happened:

```java
work.remove(i);
```

- `i` is a **value**
    
- Java treats it as an **index**
    

Why this shows up _only_ in recursion:

- list size changes dynamically
    
- indices shift after deeper calls
    

This wasnâ€™t carelessness â€” it was a **language semantic mismatch**.

---

#### ðŸ§¾ Draft2 â€” â€œI forgot about k while solving nâ€

This is a classic trap.

Your thinking at that point:

- â€œIf sum is right, path is rightâ€
    

Why it feels reasonable:

- many problems end at `sum == target`
    

How the problem corrects you:

- exact-size constraint turns â€œpartial successâ€ into invalid state
    

This draft is the moment where the problem forces:

> â€œShape matters as much as value.â€

---

#### ðŸ’¬ â€œIm pruning at the end cusâ€¦ Pick and Not Pick should happen properlyâ€

This comment is important.

What you were guarding against:

- incomplete backtracking
    
- broken mutation reset
    

What the code actually reveals:

- your intuition is about **state symmetry**
    
- but the pruning condition is about **state completeness**
    

The discomfort you felt (â€œidk for some reason it feels rightâ€) is because:

- the recursion _structure_ is fine
    
- the **meaning of the return value** is not aligned with enumeration
    

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ðŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (Intent-Only)

- `helper(...)` is defining a **state**, not asking a question
    
- `sum >= n` is a **terminal boundary**
    
- `sz > k` is a **shape violation**
    
- `i < 10` encodes the entire choice space
    

The boolean return value is the only thing that doesnâ€™t correspond to a real invariant â€” which is why it causes confusion.

---

### ðŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level Only)

- IndexOutOfBounds â†’ misunderstanding _what_ was being removed
    
- Wrong Answer â†’ enforcing sum without enforcing shape
    
- Early boolean pruning â†’ treating local failure as global information
    

Each bug traces back to:

> treating recursion as **decision logic** instead of **state enumeration**

---

### ðŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

Your structure makes it easy to:

- see what state exists
    
- see when it changes
    
- see when itâ€™s frozen
    

What becomes hard:

- reasoning about **what `true` or `false` actually means**
    

That mismatch is the real friction point â€” not recursion, not Java.

---

### ðŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

The constraint that dominates everything:

- **exactly `k` numbers**
    

Constraints that _look_ important but arenâ€™t:

- performance micro-optimizations
    
- early boolean exits
    
- manual size tracking
    

If `k` were removed:

- your pruning intuition would feel much more natural
    

---

### ðŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern name:**  
**State-Space Enumeration with Coupled Invariants**

**Plain description:**

- You donâ€™t stop when something fails
    
- You stop when the **state violates an invariant**
    
- Valid states are collected, not returned
    

**When this pattern fits:**

- exact size + exact sum
    
- bounded domains
    
- combinations, not decisions
    

**When it does NOT fit:**

- â€œis there at least one?â€
    
- reachability
    
- yes/no questions
    

**Mental note to reuse:**

> If the problem wants _all valid shapes_, recursion should **describe states**, not report success.

Thatâ€™s the realization your comments were already circling.