# Drafts
## Draft1: I overly simplified the problem
```python
class Solution:

    def permute(self, nums: List[int]) -> List[List[int]]:

        res : List[List[int]] = [] # U can hard code it to be 2^n but why bother

        n = len(nums)

        work : List[int] = [0] * n # Dont say ive hard coded it

        # im acting as per constraint

        def helper(i : int):

            if(i==n):

                res.add(work.copy())

                return

            for x in range(i, n):

                # Rather than appending we do something crazy here

                work[x] = nums[i]

                # pick

  

                # Recursive call to build more

                helper(i+1)

  

                # unpick

                work[x] = ???

                # Idk man i dont think this would work cus

                # I blissfully ignored global logic
```

## Draft2: Lol I forgot None also takes space, Invariant Error, I thought `if(work[i] != None):` will stop overriding but it checks after overriding lol lame
```python
class Solution:

    def permute(self, nums: List[int]) -> List[List[int]]:

        res : List[List[int]] = [] # U can hard code it to be 2^n but why bother

        n = len(nums)

        work : List[int] = [None] * n # Dont say ive hard coded it

        # im acting as per constraint

        def helper(i : int):

            print(" "*i, i, work)

            if(i==n):

                res.append(work.copy())

                return

  

            if(work[i] != None):

                # Override only if its None

                return

            for x in range(0, n):

                # Rather than appending we do something crazy here

                work[x] = nums[i]

                # pick

  

                # Recursive call to build more

                helper(i+1)

  

                # unpick

                work[x] = None

  

        helper(0)

        return res
```
# Code
## My Code:
```python
class Solution:

    def permute(self, nums: List[int]) -> List[List[int]]:

        res : List[List[int]] = [] # U can hard code it to be 2^n but why bother

        n = len(nums)

        work : List[int] = [None] * n # Dont say ive hard coded it

        # im acting as per constraint

        def helper(i : int):

            #print(" "*i, i, work)

            if(i==n):

                res.append(work.copy())

                return

            for x in range(0, n):

                # Only work if thts not already occupied

                if work[x] == None:

                    # Rather than appending we do something crazy here

                    work[x] = nums[i]

                    # pick

  

                    # Recursive call to build more

                    helper(i+1)

  

                    # unpick

                    work[x] = None

  

        helper(0)

        return res
```
## Optimal Code
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []

        def f(start):
            if start == len(nums):
                res.append(nums[:])
                return

            for i in range(start, len(nums)):
                nums[start], nums[i] = nums[i], nums[start]
                f(start + 1)
                nums[start], nums[i] = nums[i], nums[start]

        f(0)        
        return res
```