# Intuition
![[../../../../Pasted image 20260202132544.png]]
# Drafts
## Draft:1
```python
class Solution:

Â  Â  def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

Â  Â  Â  Â  work = []

Â  Â  Â  Â  res = []

Â  Â  Â  Â  n = len(candidates)

  

Â  Â  Â  Â  # Python unlike Java allows me to have cleaner helpers

Â  Â  Â  Â  def helper(i: int, s: int):

Â  Â  Â  Â  Â  Â  # True returned means parent can go next step

Â  Â  Â  Â  Â  Â  # False means this marks the end the parent should stop

  

Â  Â  Â  Â  Â  Â  # If Subcall gives False then u stop and give True

  

Â  Â  Â  Â  Â  Â  if i==n:

Â  Â  Â  Â  Â  Â  Â  Â  # Out of boundary check

Â  Â  Â  Â  Â  Â  Â  Â  return False

Â  Â  Â  Â  Â  Â  if s >= target:

Â  Â  Â  Â  Â  Â  Â  Â  # Sum check

Â  Â  Â  Â  Â  Â  Â  Â  if s == target:

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res.append(work.copy())

Â  Â  Â  Â  Â  Â  Â  Â  return False

Â  Â  Â  Â  Â  Â  for x in range(i, n):

Â  Â  Â  Â  Â  Â  Â  Â  # Pick

Â  Â  Â  Â  Â  Â  Â  Â  work.append(candidates[x])

  

Â  Â  Â  Â  Â  Â  Â  Â  # Recurse

Â  Â  Â  Â  Â  Â  Â  Â  subCall = helper(x, s+candidates[x])

  

Â  Â  Â  Â  Â  Â  Â  Â  # Unpick

Â  Â  Â  Â  Â  Â  Â  Â  work.pop()

  

Â  Â  Â  Â  Â  Â  Â  Â  if(subCall == False):

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  # Early pruning

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return True

  
  
  

Â  Â  Â  Â  helper(0, 0)

Â  Â  Â  Â  return res
```
## I should sort
# Code
## My Code
```python
class Solution:

Â  Â  def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

Â  Â  Â  Â  work = []

Â  Â  Â  Â  res = []

Â  Â  Â  Â  n = len(candidates)

Â  Â  Â  Â  # Fk i didnt sort it

Â  Â  Â  Â  candidates.sort()

  

Â  Â  Â  Â  # Python unlike Java allows me to have cleaner helpers

Â  Â  Â  Â  def helper(i: int, s: int):

Â  Â  Â  Â  Â  Â  # True returned means parent can go next step

Â  Â  Â  Â  Â  Â  # False means this marks the end the parent should stop

  

Â  Â  Â  Â  Â  Â  # If Subcall gives False then u stop and give True

  

Â  Â  Â  Â  Â  Â  if i==n:

Â  Â  Â  Â  Â  Â  Â  Â  # Out of boundary check

Â  Â  Â  Â  Â  Â  Â  Â  return False

Â  Â  Â  Â  Â  Â  if s >= target:

Â  Â  Â  Â  Â  Â  Â  Â  # Sum check

Â  Â  Â  Â  Â  Â  Â  Â  if s == target:

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res.append(work.copy())

Â  Â  Â  Â  Â  Â  Â  Â  return False

Â  Â  Â  Â  Â  Â  for x in range(i, n):

Â  Â  Â  Â  Â  Â  Â  Â  # Pick

Â  Â  Â  Â  Â  Â  Â  Â  work.append(candidates[x])

  

Â  Â  Â  Â  Â  Â  Â  Â  # Recurse

Â  Â  Â  Â  Â  Â  Â  Â  subCall = helper(x, s+candidates[x])

  

Â  Â  Â  Â  Â  Â  Â  Â  # Unpick

Â  Â  Â  Â  Â  Â  Â  Â  work.pop()

  

Â  Â  Â  Â  Â  Â  Â  Â  if(subCall == False):

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  # Early pruning

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return True

  
  
  

Â  Â  Â  Â  helper(0, 0)

Â  Â  Â  Â  return res
```

ðŸŒ± **Learning Summary â€” `combinationSum` (Why duplicates never appear)**

---

## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### 1ï¸âƒ£ Mental Model vs Memorization

**The instinctive approach**

The natural first reaction is:

- â€œThis is recursion with loops.â€
    
- â€œIf I can pick numbers in different orders, Iâ€™ll get duplicates.â€
    
- â€œI probably need a set / hashmap / dedup trick.â€
    

That instinct is reasonable because:

- many backtracking problems _do_ generate permutations accidentally
    
- loops + recursion often signal duplication risk
    
- youâ€™ve seen subsets-with-duplicates where explicit handling is required
    

So your mental model was:

> _â€œIâ€™m generating combinations and somehow duplicates are magically avoided.â€_

**Where it quietly breaks**

That model assumes:

- the algorithm _generates duplicates and removes them later_
    

But thatâ€™s not whatâ€™s happening.

No deduplication step exists.  
No comparison exists.  
No filtering exists.

Yet duplicates never appear.

That contradiction is the signal that the **model is wrong**, not the code.

**The decisive shift**

The correct shift is:

> **This code does not generate combinations freely.  
> It enforces an ordering rule so duplicates are impossible.**

Once you see that:

- the â€œduplicate problemâ€ disappears
    
- the recursion tree itself becomes smaller
    
- performance suddenly makes sense
    

Thatâ€™s the â€œoh â€” thatâ€™s cleanerâ€ moment.

---

## ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

People rush to classify this as:

- backtracking
    
- DFS
    
- recursion with pruning
    

Those labels push attention toward **mechanics**.

The real classification is:

> **Monotonic decision recursion over a fixed domain**

What must stay true:

- decisions only move forward
    
- once you pass an index, you never return
    
- combinations are defined by _multiset membership_, not order
    

This is **not** a permutation problem.  
Treating it like one immediately causes confusion.

---

## ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

### Decision: Use index-based recursion (`helper(x, â€¦)`)

**What the problem demands**

- combinations, not permutations
    
- reuse of the same element allowed
    
- order inside the combination irrelevant
    

**Tempting alternative**

- restart recursion from index `0`
    
- or allow backward movement
    

**Why that fights the problem**

- permutations appear instantly
    
- duplicates explode
    
- you need deduplication structures
    

Passing `x` forward enforces:

> **non-decreasing index sequence**

That single rule eliminates permutations structurally.

---

### Decision: Sort candidates first

**What the problem demands**

- pruning based on sum
    
- consistent traversal order
    

**Tempting alternative**

- skip sorting to avoid `n log n`
    

**Why that becomes awkward**

- pruning stops working reliably
    
- reasoning about â€œfuture choicesâ€ becomes harder
    

Sorting is not for deduplication here.  
It is for **monotonicity + pruning clarity**.

---

### Decision: No duplicate handling at all

This only works because of an _explicit problem constraint_:

> **All candidate values are unique.**

That constraint matters.

Because values are unique:

- index order â‡” value order
    
- structural ordering is sufficient
    
- no equal-value branching exists
    

If candidates were not unique, this exact logic would fail â€” and you already saw that in `subsetsWithDup`.

---

## ðŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why Your Artifacts Matter

Your drawn recursion tree and intuition about:

- `[3] â†’ [3,2]`
    
- â€œwhy doesnâ€™t this happen?â€
    
- â€œwhy am I not getting duplicates?â€
    

These artifacts prevent a very common confusion:

- assuming recursion explores _all orders_ by default
    

They matter at the exact moment you realize:

> â€œThe recursion never allows that path to exist.â€

Once you internalize that, you stop looking for:

- hash sets
    
- visited checks
    
- canonical forms
    

Those approaches quietly stop making sense.

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

Referring to your code:

- `i` represents **where future decisions are allowed to start**
    
- `for x in range(i, n)` enumerates _next legal choices_
    
- recursive call with `x` preserves monotonicity
    
- `work` is a **prefix of decisions**, not a partial result
    

The recursion is not:

> â€œTry everything and clean laterâ€

It is:

> â€œOnly explore paths that are legal by constructionâ€

Thatâ€™s why no deduplication exists.

---

### ðŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

**Misconception: â€œThis should produce duplicatesâ€**

- **Why it felt reasonable**
    
    - loops + recursion often do
        
    - other problems required dedup logic
        
- **How the problem exposes the flaw**
    
    - index monotonicity prevents backward moves
        
    - uniqueness of values removes equivalence classes
        
    - illegal paths never exist
        

This wasnâ€™t a coding error.  
It was an **incorrect mental model of the recursion tree**.

---

## ðŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

This structure makes reasoning easier because:

- legality is enforced before recursion
    
- no memory of â€œseen combinationsâ€ is required
    
- correctness is structural, not conditional
    

If flattened or rewritten with dedup logic:

- reasoning shifts from â€œwhat paths existâ€ to â€œwhat paths survivedâ€
    
- correctness becomes input-sensitive
    
- performance degrades quietly
    

---

## ðŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

**The constraint that actually shapes the solution**

- candidate values are unique
    

**Constraints that look important but arenâ€™t**

- avoiding sort
    
- avoiding recursion depth
    

Performance comes from:

- pruning via sorted order
    
- no duplicate branches
    
- minimal per-node overhead
    

If values were _not_ unique:

- this solution would break
    
- decision-space equivalence would need handling
    
- the entire mental model would change
    

---

## ðŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern Name**  
ðŸ‘‰ **Monotonic Combination Enumeration**

**Plain-language description**

- Always move forward in the candidate list
    
- Allow reuse by staying at the same index
    
- Never revisit earlier choices
    

**When this pattern is useful**

- Combination Sum
    
- Unbounded knapsack-style enumeration
    
- Problems with unique candidate values
    

**Where it applies (different-looking problem)**

- Combination Sum III
    
- Coin Change (enumeration version)
    

**Where it does NOT apply**

- Problems with duplicate values
    
- Permutations
    
- Order-sensitive sequences
    

**Mental note**

> _If values are unique and indices never move backward,  
> duplicates are structurally impossible._

That realization is the real win here.