# Drafts
## Draft1: I forgot tht digits cant be traversed again
```java
class Solution {

Â  Â  public boolean exist(char[][] board, String word) {

Â  Â  Â  Â  for(int i=0; i<board.length; i++){

Â  Â  Â  Â  Â  Â  for(int j=0; j<(board[0]).length; j++){

Â  Â  Â  Â  Â  Â  Â  Â  boolean res = helper(board, word, 0, i, j);

Â  Â  Â  Â  Â  Â  Â  Â  if(res==true) return true;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return false;

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  board -> source of truth

Â  Â  Â  Â  Â  Â  word -> target

Â  Â  Â  Â  Â  Â  i -> enumerator for target

Â  Â  Â  Â  Â  Â  r -> row idx

Â  Â  Â  Â  Â  Â  c -> col idx

Â  Â  Â  Â  */

Â  Â  }

  

Â  Â  boolean helper(char[][] board, String word, int i, int r, int c){

Â  Â  Â  Â  //Base Cases

Â  Â  Â  Â  //String is Completed just before out of bounds checking for some reason lol

Â  Â  Â  Â  if(i == word.length()) return true;

Â  Â  Â  Â  if(r<0 || r>=board.length || c<0 || c>=(board[0]).length) return false;

Â  Â  Â  Â  //Assuming even grid else its (board[r]).length

  

Â  Â  Â  Â  //if current works then check the neighbours

Â  Â  Â  Â  if(board[r][c] != word.charAt(i)) return false;

  

Â  Â  Â  Â  System.out.println(" ".repeat(i) + ":" + board[r][c] + ":" + word.charAt(i));

  

Â  Â  Â  Â  boolean top, rgt, btm, lft;

Â  Â  Â  Â  top = helper(board, word, i+1, r-1, c);

Â  Â  Â  Â  if(top==true) return true;

  

Â  Â  Â  Â  rgt = helper(board, word, i+1, r, c+1);

Â  Â  Â  Â  if(rgt==true) return true;

  

Â  Â  Â  Â  btm = helper(board, word, i+1, r+1, c);

Â  Â  Â  Â  if(btm==true) return true;

  

Â  Â  Â  Â  lft = helper(board, word, i+1, r, c-1);

Â  Â  Â  Â  if(lft==true) return true;

  

Â  Â  Â  Â  return false;

Â  Â  }

}
```
- In python i did it easily with mutating in place, here in java its not string but char cant update it
- In java idk im thinking of having an Extra Array

## Draft2: I forgot the domain checking omg its getting too cumbersome
```java
class Solution {

Â  Â  public boolean exist(char[][] board, String word) {

Â  Â  Â  Â  boolean[][] visited = new boolean[board.length][(board[0]).length];

Â  Â  Â  Â  for(int i=0; i<board.length; i++){

Â  Â  Â  Â  Â  Â  for(int j=0; j<(board[0]).length; j++){

Â  Â  Â  Â  Â  Â  Â  Â  boolean res = helper(board, word, 0, i, j, visited);

Â  Â  Â  Â  Â  Â  Â  Â  if(res==true) return true;

  

Â  Â  Â  Â  Â  Â  Â  Â  //Reset the visited

Â  Â  Â  Â  Â  Â  Â  Â  //How to reset a boolean array back to false??

Â  Â  Â  Â  Â  Â  Â  Â  //Arrays.fill(array, val)

Â  Â  Â  Â  Â  Â  Â  Â  //But do it in recursive call for some reason intuition told me, placing it here breaks something

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return false;

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  board -> source of truth

Â  Â  Â  Â  Â  Â  word -> target

Â  Â  Â  Â  Â  Â  i -> enumerator for target

Â  Â  Â  Â  Â  Â  r -> row idx

Â  Â  Â  Â  Â  Â  c -> col idx

Â  Â  Â  Â  Â  Â  visited -> self explanatory

Â  Â  Â  Â  */

Â  Â  }

  

Â  Â  boolean helper(char[][] board, String word, int i, int r, int c, boolean[][] visited){

Â  Â  Â  Â  //Base Cases

Â  Â  Â  Â  //String is Completed just before out of bounds checking for some reason lol

Â  Â  Â  Â  if(i == word.length()) return true;

Â  Â  Â  Â  if(r<0 || r>=board.length || c<0 || c>=(board[0]).length) return false;

Â  Â  Â  Â  //Assuming even grid else its (board[r]).length

  

Â  Â  Â  Â  //if current works then check the neighbours

Â  Â  Â  Â  if(board[r][c] != word.charAt(i)) return false;

  

Â  Â  Â  Â  System.out.println(" ".repeat(i) + ":" + board[r][c] + ":" + word.charAt(i));

  

Â  Â  Â  Â  boolean top, rgt, btm, lft;

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(visited[r-1][c] == false){ //If not visited continue else stfu

Â  Â  Â  Â  Â  Â  top = helper(board, word, i+1, r-1, c, visited);

Â  Â  Â  Â  Â  Â  if(top==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(visited[r][c+1]==false){

Â  Â  Â  Â  Â  Â  rgt = helper(board, word, i+1, r, c+1, visited);

Â  Â  Â  Â  Â  Â  if(rgt==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(visited[r+1][c]==false){

Â  Â  Â  Â  Â  Â  btm = helper(board, word, i+1, r+1, c, visited);

Â  Â  Â  Â  Â  Â  if(btm==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(visited[r][c-1]==false){

Â  Â  Â  Â  Â  Â  lft = helper(board, word, i+1, r, c-1, visited);

Â  Â  Â  Â  Â  Â  if(lft==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  Arrays.fill(visited, false);

Â  Â  Â  Â  return false;

Â  Â  }

}
```
## Draft3: Some random Error 
```java
java.lang.ArrayStoreException: java.lang.Boolean at line 3427, java.base/java.util.Arrays.fill at line 64, Solution.helper at line 6, Solution.exist at line 56, __DriverSolution__.__helper__ at line 89, __Driver__.main
```

```java
class Solution {

Â  Â  public boolean exist(char[][] board, String word) {

Â  Â  Â  Â  boolean[][] visited = new boolean[board.length][(board[0]).length];

Â  Â  Â  Â  for(int i=0; i<board.length; i++){

Â  Â  Â  Â  Â  Â  for(int j=0; j<(board[0]).length; j++){

Â  Â  Â  Â  Â  Â  Â  Â  boolean res = helper(board, word, 0, i, j, visited);

Â  Â  Â  Â  Â  Â  Â  Â  if(res==true) return true;

  

Â  Â  Â  Â  Â  Â  Â  Â  //Reset the visited

Â  Â  Â  Â  Â  Â  Â  Â  //How to reset a boolean array back to false??

Â  Â  Â  Â  Â  Â  Â  Â  //Arrays.fill(array, val)

Â  Â  Â  Â  Â  Â  Â  Â  //But do it in recursive call for some reason intuition told me, placing it here breaks something

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return false;

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  board -> source of truth

Â  Â  Â  Â  Â  Â  word -> target

Â  Â  Â  Â  Â  Â  i -> enumerator for target

Â  Â  Â  Â  Â  Â  r -> row idx

Â  Â  Â  Â  Â  Â  c -> col idx

Â  Â  Â  Â  Â  Â  visited -> self explanatory

Â  Â  Â  Â  */

Â  Â  }

  

Â  Â  boolean helper(char[][] board, String word, int i, int r, int c, boolean[][] visited){

Â  Â  Â  Â  //Base Cases

Â  Â  Â  Â  //String is Completed just before out of bounds checking for some reason lol

Â  Â  Â  Â  if(i == word.length()) return true;

Â  Â  Â  Â  if(!(isValidIdx(board, r, c))) return false;

Â  Â  Â  Â  //Assuming even grid else its (board[r]).length

  

Â  Â  Â  Â  //if current works then check the neighbours

Â  Â  Â  Â  if(board[r][c] != word.charAt(i)) return false;

  

Â  Â  Â  Â  System.out.println(" ".repeat(i) + ":" + board[r][c] + ":" + word.charAt(i));

  

Â  Â  Â  Â  boolean top, rgt, btm, lft;

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r-1,c) && visited[r-1][c] == false){ //If not visited continue else stfu

Â  Â  Â  Â  Â  Â  top = helper(board, word, i+1, r-1, c, visited);

Â  Â  Â  Â  Â  Â  if(top==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r,c+1) && visited[r][c+1]==false){

Â  Â  Â  Â  Â  Â  rgt = helper(board, word, i+1, r, c+1, visited);

Â  Â  Â  Â  Â  Â  if(rgt==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r+1,c) && visited[r+1][c]==false){

Â  Â  Â  Â  Â  Â  btm = helper(board, word, i+1, r+1, c, visited);

Â  Â  Â  Â  Â  Â  if(btm==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r,c-1) && visited[r][c-1]==false){

Â  Â  Â  Â  Â  Â  lft = helper(board, word, i+1, r, c-1, visited);

Â  Â  Â  Â  Â  Â  if(lft==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  Arrays.fill(visited, false);

Â  Â  Â  Â  return false;

Â  Â  }

  

Â  Â  boolean isValidIdx(char[][] board, int r, int c){

Â  Â  Â  Â  return ((r>=0 && r<board.length) && (c>=0 && c<(board[0]).length));

Â  Â  }

}
```
## Draft4: Omg another error due to edge case
```java
### Wrong Answer

21 / 88Â testcases passed

Editorial

Input

boardÂ =

[["a"]]

wordÂ =

"a"

Use Testcase

Stdout

:a:a

Output

false
```

```java
class Solution {

Â  Â  public boolean exist(char[][] board, String word) {

Â  Â  Â  Â  boolean[][] visited = new boolean[board.length][(board[0]).length];

Â  Â  Â  Â  for(int i=0; i<board.length; i++){

Â  Â  Â  Â  Â  Â  for(int j=0; j<(board[0]).length; j++){

Â  Â  Â  Â  Â  Â  Â  Â  boolean res = helper(board, word, 0, i, j, visited);

Â  Â  Â  Â  Â  Â  Â  Â  if(res==true) return true;

  

Â  Â  Â  Â  Â  Â  Â  Â  //Reset the visited

Â  Â  Â  Â  Â  Â  Â  Â  //How to reset a boolean array back to false??

Â  Â  Â  Â  Â  Â  Â  Â  //Arrays.fill(array, val)

Â  Â  Â  Â  Â  Â  Â  Â  //But do it in recursive call for some reason intuition told me, placing it here breaks something

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return false;

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  board -> source of truth

Â  Â  Â  Â  Â  Â  word -> target

Â  Â  Â  Â  Â  Â  i -> enumerator for target

Â  Â  Â  Â  Â  Â  r -> row idx

Â  Â  Â  Â  Â  Â  c -> col idx

Â  Â  Â  Â  Â  Â  visited -> self explanatory

Â  Â  Â  Â  */

Â  Â  }

  

Â  Â  boolean helper(char[][] board, String word, int i, int r, int c, boolean[][] visited){

Â  Â  Â  Â  //Base Cases

Â  Â  Â  Â  //String is Completed just before out of bounds checking for some reason lol

Â  Â  Â  Â  if(i == word.length()) return true;

Â  Â  Â  Â  if(!(isValidIdx(board, r, c))) return false;

Â  Â  Â  Â  //Assuming even grid else its (board[r]).length

  

Â  Â  Â  Â  //if current works then check the neighbours

Â  Â  Â  Â  if(board[r][c] != word.charAt(i)) return false;

  

Â  Â  Â  Â  System.out.println(" ".repeat(i) + ":" + board[r][c] + ":" + word.charAt(i));

  

Â  Â  Â  Â  boolean top, rgt, btm, lft;

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r-1,c) && visited[r-1][c] == false){ //If not visited continue else stfu

Â  Â  Â  Â  Â  Â  top = helper(board, word, i+1, r-1, c, visited);

Â  Â  Â  Â  Â  Â  if(top==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r,c+1) && visited[r][c+1]==false){

Â  Â  Â  Â  Â  Â  rgt = helper(board, word, i+1, r, c+1, visited);

Â  Â  Â  Â  Â  Â  if(rgt==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r+1,c) && visited[r+1][c]==false){

Â  Â  Â  Â  Â  Â  btm = helper(board, word, i+1, r+1, c, visited);

Â  Â  Â  Â  Â  Â  if(btm==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  visited[r][c] = true;

Â  Â  Â  Â  if(isValidIdx(board,r,c-1) && visited[r][c-1]==false){

Â  Â  Â  Â  Â  Â  lft = helper(board, word, i+1, r, c-1, visited);

Â  Â  Â  Â  Â  Â  if(lft==true) return true;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int m=0; m<visited.length; m++){

Â  Â  Â  Â  Â  Â  for(int n=0; n<visited.length; n++){

Â  Â  Â  Â  Â  Â  Â  Â  visited[m][n] = false;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  //Arrays.fill(visited, false);

Â  Â  Â  Â  return false;

Â  Â  }

  

Â  Â  boolean isValidIdx(char[][] board, int r, int c){

Â  Â  Â  Â  return ((r>=0 && r<board.length) && (c>=0 && c<(board[0]).length));

Â  Â  }

}
```
- Im mixing a lot of stuff here and there
- Dont prevent recursive calls in backtracking but rather make it kill itself
# Code
## My Old Code
```python
class Solution:

    def helper(self, board, word, m, n, l, i=0, j=0, k=0):
        #(i,j) of mxn
        #k of l
        
        #Early Failure condition
        if (i<0 or i>=m) or (j<0 or j>=n):
            #Stepped out
            return False
        
        if board[i][j][0] == "#":
            #Already visited
            return False

        if board[i][j] == word[k]:

            if k==l-1:
                #Yep done
                return True

            board[i][j] = board[i][j] + "#"
            #Proceed further
            #Right
            right = self.helper(board,word,m,n,l,i,j+1,k+1)

            #Down
            down = self.helper(board,word,m,n,l,i+1,j,k+1)

            #Left
            left = self.helper(board,word,m,n,l,i-1,j,k+1)

            #Up
            up = self.helper(board,word,m,n,l,i,j-1,k+1)

            board[i][j] = board[i][j][0:len(board[i][j])-1]

            if right or down or left or up:
                return True
        return False




    def exist(self, board: List[List[str]], word: str) -> bool:
        l = len(word)
        m = len(board)
        n = len(board[0])
        val = False
        if len(word) > m*n:
            return False

        for i in range(m):
            for j in range(n):

                if self.helper(board,word, m, n, l, i, j):
                    return True
        
        return False
```

## My Code
```java
class Solution {

    public boolean exist(char[][] board, String word) {

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (helper(board, word, 0, i, j, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    boolean helper(char[][] board, String word, int i, int r, int c, boolean[][] visited) {

        // âœ… success condition
        if (i == word.length()) return true;

        // âœ… bounds + reuse guard
        if (!isValidIdx(board, r, c) || visited[r][c]) return false;

        // âœ… character mismatch
        if (board[r][c] != word.charAt(i)) return false;

        // âœ… mark current cell
        visited[r][c] = true;

        // explore 4 directions
        boolean found =
                helper(board, word, i + 1, r - 1, c, visited) ||
                helper(board, word, i + 1, r + 1, c, visited) ||
                helper(board, word, i + 1, r, c - 1, visited) ||
                helper(board, word, i + 1, r, c + 1, visited);

        // âœ… undo (THIS was missing / misplaced before)
        visited[r][c] = false;

        return found;
    }

    boolean isValidIdx(char[][] board, int r, int c) {
        return r >= 0 && r < board.length && c >= 0 && c < board[0].length;
    }
}

```
- Here the Recursive call prevention doesnt messup
- We cleanly go thru the edge cases
- Key thing i learnt is, let recursion handle itself dont u dare prevent a recursive call by sensing a problem locally

## ğŸ§  Learning Reflection â€” Word Search (Backtracking on Grid)

---

## ğŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### 1ï¸âƒ£ Mental Model vs Memorization

Your _first instinct_ was completely natural:  
you treated the grid like a graph and recursion like a DFS that â€œjust keeps goingâ€ as long as characters match.

That instinct worked in Python because you **mutated the board itself** (`"#"` marker), so the _state_ was implicit.  
When you moved to Java, that hidden crutch disappeared â€” and suddenly recursion felt fragile and manual.

The quiet break happened here:

- You were **thinking in terms of control flow**  
    (â€œdonâ€™t go thereâ€, â€œreset everythingâ€, â€œprevent the callâ€)
    
- But the problem wanted **state flow**  
    (â€œmark â†’ explore â†’ undo, per pathâ€)
    

The decisive shift was realizing this:

> A cell being â€œusedâ€ is **not global truth** â€” itâ€™s **temporary truth for one path**.

Once that clicks, everything collapses cleanly:

- No global resets
    
- No defensive blocking
    
- No fear of recursion â€œrunning awayâ€
    

You stop _managing recursion_ and start _describing state_.

---

### ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

Itâ€™s tempting to label this as:

- DFS
    
- Backtracking
    
- Grid traversal
    

But those labels pulled your attention away from what you were _actually reasoning about_:

- **Can this cell be reused in the same path?** â†’ no
    
- **Can it be reused in a different path?** â†’ yes
    
- **Who owns that decision?** â†’ the current recursive call
    

This isnâ€™t about traversal â€” itâ€™s about **path-local ownership of state**.

Thatâ€™s why attempts to â€œreset visitedâ€ globally felt cursed:

- They violated the invariant you _intuitively_ wanted but hadnâ€™t named yet.
    

---

### ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

Each major decision you struggled with was forced by the problem â€” not by rules.

- **Extra `visited` array**
    
    - Problem demand: Java canâ€™t mutate characters like Python strings
        
    - Temptation: reset the whole array
        
    - Friction: kills valid paths and edge cases (`[["a"]]`, `"a"`)
        
- **Guarding recursive calls**
    
    - Temptation: â€œdonâ€™t recurse if something looks wrongâ€
        
    - Friction: recursion already _knows_ how to die via base cases
        
- **Resetting `visited`**
    
    - Temptation: clean slate thinking
        
    - Reality: only _this call_ polluted the state â€” only _this call_ should clean it
        

Each â€œhackâ€ felt necessary until you noticed:

> every hack was compensating for missing an **undo**.

---

### ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why Your Drafts Matter

Your drafts arenâ€™t noise â€” theyâ€™re checkpoints.

- **Draft 1 (no visited)**
    
    - Prevents forgetting that _cells canâ€™t be reused_
        
    - Common mistake when moving from string to grid problems
        
- **Draft 2 (visited + global reset)**
    
    - Shows the exact moment you confused _path state_ with _global state_
        
- **Draft 3 (`Arrays.fill` crash)**
    
    - Exposes that Java arrays arenâ€™t magic â€” structure matters
        
- **Draft 4 (edge case failure)**
    
    - The `[["a"]] â†’ "a"` failure is the perfect signal:
        
        > â€œYour logic works globally, but breaks locally.â€
        

Each artifact pushed you closer to the real invariant without telling you directly.

Once the invariant clicked, _all_ these drafts stopped making sense to keep.

---

## ğŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ğŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

Only the non-obvious parts:

- **Base case first (`i == word.length()`)**
    
    - Success should short-circuit everything below it
        
    - Explains why your single-cell case now works
        
- **Bounds + visited check together**
    
    - These are _invalid state_ checks, not logic decisions
        
- **Mark once, undo once**
    
    - Anything more means state is leaking across calls
        

---

### ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

Every bug maps to a mental model gap:

- _â€œI should reset visitedâ€_ â†’ confusing ownership
    
- _â€œI should prevent recursionâ€_ â†’ mistrusting base cases
    
- _â€œWhy does Python work but Java doesnâ€™t?â€_ â†’ mutation hiding state
    

None of these were syntax problems.  
They were **state ownership problems**.

---

### ğŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

Your final structure is clean because:

- Each recursive call:
    
    - owns exactly **one cell**
        
    - cleans up exactly **one mutation**
        
- The outer loops:
    
    - donâ€™t interfere
        
    - donâ€™t reset
        
    - donâ€™t micromanage
        

If you flattened this logic or added guards outside recursion, reasoning would break immediately.

---

### ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

The _one constraint that shapes everything_:

> **Cells may not be reused within a path, but must be reusable across paths.**

Things that looked important but werenâ€™t:

- DFS order
    
- Direction priority
    
- Starting cell heuristics
    

Language difference insight (tied to your comments):

- Python: mutation hides backtracking
    
- Java: explicit undo forces understanding  
    â†’ painful, but permanent learning
    

---

### ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern:** Grid Backtracking with Path-Local State

- **Plain-language**
    
    - â€œClaim a cell, explore from it, then release it.â€
        
- **Use when**
    
    - Paths matter
        
    - Reuse is forbidden _temporarily_, not permanently
        
- **Does NOT apply when**
    
    - State is global and monotonic (e.g., flood fill, connected components)
        

**Mental note to reuse later:**

> When you feel the urge to â€œreset everythingâ€, youâ€™re probably forgetting to **undo one thing**.

---

This wasnâ€™t rage-quit-worthy.  
This was the exact struggle that turns backtracking from a trick into a tool.