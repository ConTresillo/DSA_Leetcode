# Drafts
## Draft1: i put `i+1` instead of `x+1`, forgot pruning
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum2(int[] candidates, int target) Â  Â 

Â  Â  {

  

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  Arrays.sort(candidates);

Â  Â  Â  Â  //System.out.println(Arrays.toString(candidates));

Â  Â  Â  Â  helper(candidates, target, res, work, 0, 0);

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  candidates -> source of truth

Â  Â  Â  Â  Â  Â  target -> self explanatory

Â  Â  Â  Â  Â  Â  res -> storage

Â  Â  Â  Â  Â  Â  work -> mutable buffer

Â  Â  Â  Â  Â  Â  i -> anything below this index ignored

Â  Â  Â  Â  Â  Â  sum -> keeps track of sum of work gives O(1) access

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

Â  Â  Â  Â  System.out.println(work);

  

Â  Â  Â  Â  if(sum >= target){

Â  Â  Â  Â  Â  Â  if(sum == target)

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<>(work));

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=i; x<candidates.length; x++){

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Explore

Â  Â  Â  Â  Â  Â  helper(candidates, target, res, work, i+1, sum+candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

Â  Â  Â  Â  }

Â  Â  }

  

}
```
## Draft2: Still idk how to reject duplicates
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum2(int[] candidates, int target) Â  Â 

Â  Â  {

  

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  Arrays.sort(candidates);

Â  Â  Â  Â  //System.out.println(Arrays.toString(candidates));

Â  Â  Â  Â  helper(candidates, target, res, work, 0, 0);

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  candidates -> source of truth

Â  Â  Â  Â  Â  Â  target -> self explanatory

Â  Â  Â  Â  Â  Â  res -> storage

Â  Â  Â  Â  Â  Â  work -> mutable buffer

Â  Â  Â  Â  Â  Â  i -> anything below this index ignored

Â  Â  Â  Â  Â  Â  sum -> keeps track of sum of work gives O(1) access

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

Â  Â  Â  Â  System.out.println(work);

  

Â  Â  Â  Â  if(sum >= target){

Â  Â  Â  Â  Â  Â  if(sum == target)

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<>(work));

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=i; x<candidates.length; x++){

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Explore

Â  Â  Â  Â  Â  Â  helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

Â  Â  Â  Â  }

Â  Â  }

  

}
```

## Draft3: Time limit exceeded but testcase passed
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum2(int[] candidates, int target) Â  Â 

Â  Â  {

  

Â  Â  Â  Â  Set<List<Integer>> res = new HashSet<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  Arrays.sort(candidates);

Â  Â  Â  Â  //System.out.println(Arrays.toString(candidates));

Â  Â  Â  Â  helper(candidates, target, res, work, 0, 0);

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  candidates -> source of truth

Â  Â  Â  Â  Â  Â  target -> self explanatory

Â  Â  Â  Â  Â  Â  res -> storage

Â  Â  Â  Â  Â  Â  work -> mutable buffer

Â  Â  Â  Â  Â  Â  i -> anything below this index ignored

Â  Â  Â  Â  Â  Â  sum -> keeps track of sum of work gives O(1) access

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return new ArrayList<List<Integer>>(res);

Â  Â  }

  

Â  Â  void helper(int[] candidates, int target, Set<List<Integer>> res, List<Integer> work, int i, int sum){

Â  Â  Â  Â  //System.out.println(work);

  

Â  Â  Â  Â  if(sum >= target){

Â  Â  Â  Â  Â  Â  if(sum == target)

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<>(work));

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=i; x<candidates.length; x++){

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Explore

Â  Â  Â  Â  Â  Â  helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

Â  Â  Â  Â  }

Â  Â  }

  

}
```

# Code
## My code:
```java
class Solution {

Â  Â  public List<List<Integer>> combinationSum2(int[] candidates, int target) Â  Â 

Â  Â  {

  

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  Arrays.sort(candidates);

Â  Â  Â  Â  //System.out.println(Arrays.toString(candidates));

Â  Â  Â  Â  helper(candidates, target, res, work, 0, 0);

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  candidates -> source of truth

Â  Â  Â  Â  Â  Â  target -> self explanatory

Â  Â  Â  Â  Â  Â  res -> storage

Â  Â  Â  Â  Â  Â  work -> mutable buffer

Â  Â  Â  Â  Â  Â  i -> anything below this index ignored

Â  Â  Â  Â  Â  Â  sum -> keeps track of sum of work gives O(1) access

Â  Â  Â  Â  */

  

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

Â  Â  Â  Â  //System.out.println(work);

  

Â  Â  Â  Â  if(sum >= target){

Â  Â  Â  Â  Â  Â  if(sum == target)

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<>(work));

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=i; x<candidates.length; x++){

  

Â  Â  Â  Â  Â  Â  //Core skipping thingy I learnt

Â  Â  Â  Â  Â  Â  // Why not x>0 but x>i

Â  Â  Â  Â  Â  Â  if(x>i && candidates[x] == candidates[x-1])

Â  Â  Â  Â  Â  Â  Â  Â  continue;

  

Â  Â  Â  Â  Â  Â  // Pick

Â  Â  Â  Â  Â  Â  work.add(candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Explore

Â  Â  Â  Â  Â  Â  helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

Â  Â  Â  Â  Â  Â  // Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

Â  Â  Â  Â  }

Â  Â  }

  

}
```

## ğŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### 1ï¸âƒ£ Mental Model vs Memorization

- Your instinctive model, visible from Draft 1 onward, was:  
    _â€œIâ€™m building combinations by picking elements and moving forward; if I move the index correctly, things should line up.â€_  
    That instinct is reasonable because it worked for **Combination Sum I** and other pick-only problems.
    
- Where it quietly breaks is subtle:  
    you were still thinking **â€œeach element is unique by positionâ€**, while the problemâ€™s reality is **â€œvalues can repeat, positions donâ€™t matter.â€**  
    That mismatch is exactly why duplicates started appearing and why `HashSet` felt tempting.
    
- The decisive shift you eventually made is this:  
    **the recursion level (depth) defines a â€œchoice layer,â€ and duplicates are illegal only within the same layer.**  
    Once that clicks, the skip rule stops feeling like a trick and starts feeling inevitable.
    
- After that shift, the solution space collapses naturally:
    
    - You no longer need global deduplication.
        
    - You no longer need canonicalization.
        
    - You only need to prevent identical sibling branches from spawning.
        

The moment you understood _why_ `x > i` exists, not just _that_ it exists, the problem essentially solved itself.

---

### ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

- Itâ€™s very tempting to label this as:
    
    - â€œbacktrackingâ€
        
    - â€œcombination generationâ€
        
    - or even â€œset-based deduplicationâ€
        
- Those labels pull attention toward **tools** (sets, maps, pruning tricks) instead of the real invariant you were wrestling with:
    
    > _At a fixed recursion depth, each value should start at most one branch._
    
- This problem is not about _generating combinations_ in general.  
    Itâ€™s about **controlling branching symmetry**.
    
- Once framed that way, the categories stop mattering.  
    The only question left is:
    
    > â€œHow do I stop identical siblings without blocking valid descendants?â€
    

That framing is exactly what your final solution reflects.

---

### ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Sorting the array**
    
    - What the problem demanded: a way to detect equal values locally.
        
    - The tempting alternative: dedupe after the fact (`Set<List<Integer>>`).
        
    - Why that alternative fights the problem: it lets duplicates explode first, then cleans up laterâ€”expensive and mentally backward.
        
- **Using `x + 1` instead of `i + 1`**
    
    - What the problem demanded: each element used at most once _per branch_.
        
    - The tempting alternative: reuse `i + 1` because â€œwe already moved forward.â€
        
    - Why it leaks: it ignores which element was actually chosen, causing repeated reuse and invalid paths.
        
- **Skipping when `x > i && candidates[x] == candidates[x-1]`**
    
    - What the problem demanded: block duplicate siblings.
        
    - The tempting alternative: block duplicates globally (`x > 0`) or via hashing.
        
    - Why those feel fragile: they confuse _depth_ with _position_.
        

None of these are arbitrary rules. Each emerges because the problem starts resisting the simpler idea.

---

### ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why _Your_ Artifacts Matter

- **Draft 1 (`i+1` instead of `x+1`)**
    
    - Prevents the confusion that â€œindex movement is independent of choice.â€
        
    - Common confusion because many recursion problems hide this distinction.
        
    - Matters exactly when branching starts depending on _which_ element was picked.
        
- **Draft 2 (no duplicate handling)**
    
    - Exposes the illusion that â€œsorted input magically fixes duplicates.â€
        
    - Common because sorting feels like a silver bullet.
        
    - Matters when identical values generate identical sibling branches.
        
- **Draft 3 (HashSet approach)**
    
    - Prevents the false belief that correctness implies efficiency.
        
    - Common because sets _do_ produce correct output.
        
    - Matters when time complexity explodes despite logical correctness.
        
- **Your comment: â€œWhy not x > 0 but x > iâ€**
    
    - This is the core artifact.
        
    - It keeps you from accidentally rejecting valid branches that start at deeper levels.
        
    - Once understood, almost every other approach stops making sense.
        

**Insight compression:**  
Once you see recursion as _layers of choice_, global deduplication, canonicalization, and post-processing quietly become unnecessary.

---

## ğŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ğŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

- The `sum >= target` check exists to **terminate branches early**, not just to check success.
    
    - Without it, branches continue growing uselessly.
        
- Passing `x + 1` into recursion encodes:
    
    > â€œEverything before `x` is now frozen history.â€
    
- The skip condition is intentionally inside the loop, not at the function boundary.
    
    - If moved elsewhere, it would either over-skip or under-skip.
        

Each piece exists because removing it reintroduces one of the exact bugs you hit earlier.

---

### ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Using `HashSet<List<Integer>>`**
    
    - Thinking: â€œDuplicates are a storage problem.â€
        
    - Why it feels reasonable: sets eliminate duplicates everywhere else.
        
    - How the problem exposes it: exponential generation before deduplication.
        
- **Missing duplicate skipping**
    
    - Thinking: â€œEach recursive call moves forward, so duplicates shouldnâ€™t repeat.â€
        
    - Why it feels reasonable: index monotonicity feels sufficient.
        
    - Exposure: identical values at the same depth still create identical branches.
        
- **Confusion between `i` and `x`**
    
    - Thinking: â€œThe loop already controls the index.â€
        
    - Why it feels reasonable: in many problems, it does.
        
    - Exposure: branch identity depends on the _chosen element_, not the loop start.
        

Each bug corresponds to a mental model that was almost rightâ€”but incomplete.

---

### ğŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

- The separation between:
    
    - loop (`x`)
        
    - recursion boundary (`i`)
        
    
    makes it possible to reason about:
    
    - _who_ chose an element
        
    - _when_ duplicates should be blocked
        
- Flattening this logic would blur sibling vs ancestor decisions and reintroduce accidental duplicates.
    

The structure matches how your thinking eventually stabilized.

---

### ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

- The single shaping constraint here is:  
    **values may repeat, but combinations must not.**
    
- Constraints that look important but arenâ€™t:
    
    - Output order
        
    - Storage container type
        
- Java vs Python differences show up mechanically:
    
    - Java forces you to be explicit about copying.
        
    - Python hides some of that cost, which can mask inefficiencies.
        

If duplicates were not allowed in input, the entire skip rule would disappearâ€”and your earlier drafts would suddenly be optimal.

---

### ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

- **Pattern name:** Layer-based duplicate skipping
    
- **Plain description:**  
    At each recursion depth, allow each distinct value to start only one branch.
    
- **When it applies:**
    
    - Combination problems with repeated values
        
    - â€œChoose some elements, order doesnâ€™t matterâ€
        
- **Where it applies differently:**
    
    - `Subsets II`
        
    - `Combination Sum II`
        
- **Where it does NOT apply:**
    
    - Permutations (order matters; duplicates handled differently)
        

**Mental note:**

> â€œWhen recursion branches look identical, ask:  
> am I blocking duplicates across time, or across layers?â€