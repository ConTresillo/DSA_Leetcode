# Drafts
## Draft1: I cant access the List purely JAVA syntax error
```java
class Solution {

Â  Â  public List<String> letterCombinations(String digits) {

Â  Â  Â  Â  StringBuilder work = new StringBuilder();

Â  Â  Â  Â  List<StringBuilder> res = new ArrayList<>();

Â  Â  Â  Â  Map<Integer, List<Character>> map = new HashMap<>();

Â  Â  Â  Â  initMap(map);

Â  Â  Â  Â  //System.out.println(map.get(2).get(0));

  

Â  Â  Â  Â  helper(digits, 0, map, work, res);

Â  Â  Â  Â  /*

Â  Â  Â  Â  Â  Â  digits -> source of truth useful for conversion

Â  Â  Â  Â  Â  Â  i -> digit enumerator

Â  Â  Â  Â  Â  Â  map -> use it to convert num to alphabet

Â  Â  Â  Â  Â  Â  splits into many branches

Â  Â  Â  Â  Â  Â  work -> it stores the current stable state just before mutation

Â  Â  Â  Â  Â  Â  res -> it stores the valid results

Â  Â  Â  Â  */

Â  Â  Â  Â  return null;

Â  Â  }

Â  Â  void helper(String digits, int i, Map<Integer, List<Character>> map, StringBuilder work, List<StringBuilder> res){

Â  Â  Â  Â  //Base Case

Â  Â  Â  Â  //If i >= digits.length

Â  Â  Â  Â  if(i >= digits.length()){

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â  List<Character> list = map.get(digits.charAt(i));

Â  Â  Â  Â  System.out.println(list);

Â  Â  Â  Â  /*for(int x=0; x<list.size(); x++){

Â  Â  Â  Â  Â  Â  System.out.println(list.get(x));

Â  Â  Â  Â  }*/

Â  Â  }

  

Â  Â  void initMap(Map<Integer, List<Character>> map){

Â  Â  Â  Â  map.put(2, List.of('a','b','c'));

Â  Â  Â  Â  map.put(3, List.of('d', 'e', 'f'));

Â  Â  Â  Â  map.put(4, List.of('g', 'h', 'i'));

Â  Â  Â  Â  map.put(5, List.of('j', 'k', 'l'));

Â  Â  Â  Â  map.put(6, List.of('m','n','o'));

Â  Â  Â  Â  map.put(7, List.of('p','q','r','s'));

Â  Â  Â  Â  map.put(8, List.of('t', 'u', 'v'));

Â  Â  Â  Â  map.put(9, List.of('w','x','y','z'));

Â  Â  }

  

}
```
- Turns out i fked up the Character parsing to Int lol
# Codes
## My Old Code (8 months back I didnt learn Recursion properly I was scared of it)
```python
import itertools

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        D = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z']
        }
        L=[]
        for ch in digits:
            L.append(D[ch])
        L = list(itertools.product(*L))
        L = ["".join(comb) for comb in L]
        if not L[0] : return []
        return L
```

## My Code
```java
class Solution {
    public List<String> letterCombinations(String digits) {
        
        StringBuilder work = new StringBuilder();
        List<String> res = new ArrayList<>();
        Map<Integer, List<Character>> map = new HashMap<>();
        initMap(map);
        //System.out.println(map.get(2).get(0));

        helper(digits, 0, map, work, res);
        /*
            digits -> source of truth useful for conversion
            i -> digit enumerator
            map -> use it to convert num to alphabet 
            splits into many branches
            work -> it stores the current stable state just before mutation
            res -> it stores the valid results
        */
        return res;
    }
    
    void helper(String digits, int i, Map<Integer, List<Character>> map, StringBuilder work, List<String> res){
        //Base Case
        //If i >= digits.length
        if(i >= digits.length()){
            res.add(work.toString());
            return;
        }
        List<Character> list = map.get(digits.charAt(i)-'0');
        //System.out.println(list);
        for(int x=0; x<list.size(); x++){
            //System.out.println(list.get(x));
            //Use Backtracking: Pick Recurse Unpick
            work.append(list.get(x));
            helper(digits, i+1, map, work, res);
            work.deleteCharAt(work.length()-1);
        }
    }

    void initMap(Map<Integer, List<Character>> map){
        map.put(2, List.of('a','b','c'));
        map.put(3, List.of('d', 'e', 'f'));
        map.put(4, List.of('g', 'h', 'i'));
        map.put(5, List.of('j', 'k', 'l'));
        map.put(6, List.of('m','n','o'));
        map.put(7, List.of('p','q','r','s'));
        map.put(8, List.of('t', 'u', 'v'));
        map.put(9, List.of('w','x','y','z'));
    }

}
```
## Optimal Code
```java
import java.util.*;

class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();
        if (digits == null || digits.length() == 0) return result;

        String[] map = {
            "",    "",    "abc",  "def",
            "ghi", "jkl", "mno",  "pqrs",
            "tuv", "wxyz"
        };

        backtrack(digits, 0, new StringBuilder(), result, map);
        return result;
    }

    private void backtrack(String digits, int index, StringBuilder path,
                           List<String> result, String[] map) {

        if (index == digits.length()) {
            result.add(path.toString());
            return;
        }

        String letters = map[digits.charAt(index) - '0'];

        for (char ch : letters.toCharArray()) {
            path.append(ch);
            backtrack(digits, index + 1, path, result, map);
            path.deleteCharAt(path.length() - 1); // undo
        }
    }
}
```
- I see theyve used Array
- HashMap is over kill for this
- I learnt this in Hashing, domain hashing means
- Ascii -> 128, small letters -> 27, So yeah here theyve done for 0-9
- Simple stuff, THe problem is i learnt it in Hashing need to apply all the knowledge i learnt lol

## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ðŸ§  1ï¸âƒ£ Mental Model vs Memorization

- Your first instinct was to treat this as a **mapping + iteration problem**.
    
    - Digits â†’ letters â†’ somehow combine them.
        
    - This is why your old Python solution jumped straight to `itertools.product`.
        
    - That instinct is reasonable because the output _looks_ like a Cartesian product.
        
- Where that instinct quietly breaks:
    
    - Cartesian product thinking hides **how combinations are built step-by-step**.
        
    - You donâ€™t control _when_ a character is chosen, only that all combinations appear.
        
    - This makes it hard to:
        
        - prune,
            
        - mutate state safely,
            
        - or generalize to harder problems (like constraints or partial validity).
            
- The small but decisive shift you made:
    
    - You stopped thinking in terms of â€œgenerate all at onceâ€.
        
    - You started thinking in terms of:
        
        - **one digit â†’ one decision layer**
            
        - **one character appended per layer**
            
    - The moment you introduced:
        
        - `i` as _â€œwhich digit am I resolving?â€_
            
        - `work` as _â€œthe string built so farâ€_
            
    - the problem collapsed into a clean recursive tree.
        
- Why this shift matters:
    
    - Every recursive level answers exactly one question:
        
        > â€œWhich letter do I pick for this digit?â€
        
    - Nothing else leaks into the decision.
        
    - No guessing, no global reasoning.
        

---

### ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

- Itâ€™s tempting to label this as:
    
    - hashing (because of digit â†’ letters),
        
    - recursion (because thereâ€™s a helper),
        
    - or backtracking (because of pick/unpick).
        
- Those labels are misleading **if used first**.
    
    - HashMap vs array distracted you early.
        
    - You correctly noticed later: this is **domain hashing**, not algorithmic hashing.
        
- The real invariant you were reasoning about:
    
    - At depth `i`, `work.length() == i`
        
    - `work` is always a valid prefix.
        
    - No prefix is ever invalid.
        
- This is not about:
    
    - checking validity,
        
    - rejecting bad states,
        
    - or pruning paths.
        
- Itâ€™s about **enumeration with guaranteed validity**.
    
    - Every partial string is acceptable.
        
    - Only completion matters.
        

---

### ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Using `i` instead of slicing digits**
    
    - What the problem demanded:
        
        - A stable way to move forward exactly one digit at a time.
            
    - The tempting alternative:
        
        - Passing substrings.
            
    - Why that fights the problem:
        
        - Substrings duplicate state and hide progress.
            
- **Using `StringBuilder` instead of `String`**
    
    - What the problem demanded:
        
        - Repeated mutation and reversal.
            
    - The tempting alternative:
        
        - Pure strings with concatenation.
            
    - Why that fights the problem:
        
        - Immutability silently turns backtracking into allocation.
            
- **Using a loop inside recursion**
    
    - What the problem demanded:
        
        - Multiple choices per digit.
            
    - The tempting alternative:
        
        - Nested ifs or product-style thinking.
            
    - Why that feels leaky:
        
        - You lose symmetry and scalability.
            
- **Array instead of HashMap in the optimal**
    
    - What the problem demanded:
        
        - Constant-time digit â†’ letters.
            
    - The tempting alternative:
        
        - HashMap (because â€œmappingâ€).
            
    - Why thatâ€™s overkill:
        
        - The domain is fixed and indexed.
            

---

### ðŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why _Your_ Artifacts Matter

- **Draft1 (Character â†’ Integer bug)**
    
    - Prevents the confusion that Java `char` â‰  digit value.
        
    - Common because Java hides numeric intent behind ASCII.
        
    - This mattered exactly when:
        
        - `map.get(digits.charAt(i))` returned `null`.
            
- **Your comment about HashMap being overkill**
    
    - Keeps you from over-engineering.
        
    - Shows you already learned domain hashing earlier.
        
    - This clicked when you saw the array-based optimal.
        
- **Old Python itertools solution**
    
    - Shows fear-avoidance of recursion, not lack of ability.
        
    - Important contrast:
        
        - Same output, zero control.
            
    - Helps explain why recursion feels powerful _now_.
        
- **Pick â†’ recurse â†’ delete**
    
    - This artifact prevents accidental carry-over.
        
    - You explicitly acknowledged:
        
        > â€œwork stores the current stable state just before mutationâ€
        
    - That sentence is a backtracking invariant in disguise.
        

**Insight compression:**  
Once you see this as â€œdepth = digit indexâ€, any solution that doesnâ€™t respect that structure feels unnatural.

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ðŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

- **Base case (`i >= digits.length`)**
    
    - Exists to mark completion, not failure.
        
    - Without it:
        
        - strings never finalize,
            
        - or you append incomplete prefixes.
            
- **Loop over mapped letters**
    
    - Exists because the choice count varies (3 vs 4).
        
    - If replaced with hardcoded branches:
        
        - the code explodes.
            
- **`work.deleteCharAt(...)`**
    
    - Exists to restore the exact previous state.
        
    - If skipped or misplaced:
        
        - later branches inherit junk.
            

---

### ðŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Character parsing bug**
    
    - Thinking: â€œdigit is a digitâ€.
        
    - Reality: Java stores characters, not numbers.
        
    - The problem exposed it immediately with `null`.
        
- **Returning empty results early**
    
    - Thinking: â€œno digits means no workâ€.
        
    - Reality:
        
        - empty input is a special semantic case.
            
    - This is why optimal checks `digits.length() == 0`.
        

---

### ðŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

- Separation of:
    
    - mapping initialization,
        
    - recursive logic,
        
    - result storage
        
- This prevents:
    
    - mental stack overflow.
        
- Flattening these would:
    
    - force you to reason about mapping and recursion at once.
        

---

### ðŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

- The real constraint:
    
    - branching factor varies per digit.
        
- Constraints that donâ€™t matter here:
    
    - time complexity optimization (output dominates),
        
    - duplicate handling (digits map uniquely).
        
- Java vs Python:
    
    - Python hides mutation cost with strings.
        
    - Java forces you to confront it.
        
    - Thatâ€™s why `StringBuilder` matters.
        
- If the constraint changed (e.g., invalid prefixes):
    
    - pruning would suddenly matter,
        
    - and this would shift toward classic backtracking.
        

---

### ðŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

- **Pattern name:** Multiple-Choice Recursion
    
- **Plain description:**
    
    - Each position offers several valid choices.
        
    - You try each, move forward, then undo.
        
- **Useful when:**
    
    - order matters,
        
    - choices depend on position.
        
- **Applies to:**
    
    - phone keypad,
        
    - IP address restoration,
        
    - word expansion problems.
        
- **Does NOT apply to:**
    
    - problems where choices depend on past validity (e.g., parentheses).
        

**Mental note:**

> When every prefix is valid and only completion matters, stop pruning â€” just enumerate cleanly.