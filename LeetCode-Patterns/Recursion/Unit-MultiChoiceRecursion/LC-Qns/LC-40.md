# Drafts
## Draft1: i put `i+1` instead of `x+1`, forgot pruning
```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target)    

    {

  

        List<List<Integer>> res = new ArrayList<>();

        List<Integer> work = new ArrayList<>();

        Arrays.sort(candidates);

        //System.out.println(Arrays.toString(candidates));

        helper(candidates, target, res, work, 0, 0);

        /*

            candidates -> source of truth

            target -> self explanatory

            res -> storage

            work -> mutable buffer

            i -> anything below this index ignored

            sum -> keeps track of sum of work gives O(1) access

        */

  

        return res;

    }

  

    void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

        System.out.println(work);

  

        if(sum >= target){

            if(sum == target)

                res.add(new ArrayList<>(work));

            return;

        }

  

        for(int x=i; x<candidates.length; x++){

            // Pick

            work.add(candidates[x]);

  

            // Explore

            helper(candidates, target, res, work, i+1, sum+candidates[x]);

  

            // Unpick

            work.remove(work.size()-1);

        }

    }

  

}
```
## Draft2: Still idk how to reject duplicates
```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target)    

    {

  

        List<List<Integer>> res = new ArrayList<>();

        List<Integer> work = new ArrayList<>();

        Arrays.sort(candidates);

        //System.out.println(Arrays.toString(candidates));

        helper(candidates, target, res, work, 0, 0);

        /*

            candidates -> source of truth

            target -> self explanatory

            res -> storage

            work -> mutable buffer

            i -> anything below this index ignored

            sum -> keeps track of sum of work gives O(1) access

        */

  

        return res;

    }

  

    void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

        System.out.println(work);

  

        if(sum >= target){

            if(sum == target)

                res.add(new ArrayList<>(work));

            return;

        }

  

        for(int x=i; x<candidates.length; x++){

            // Pick

            work.add(candidates[x]);

  

            // Explore

            helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

            // Unpick

            work.remove(work.size()-1);

        }

    }

  

}
```

## Draft3: Time limit exceeded but testcase passed
```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target)    

    {

  

        Set<List<Integer>> res = new HashSet<>();

        List<Integer> work = new ArrayList<>();

        Arrays.sort(candidates);

        //System.out.println(Arrays.toString(candidates));

        helper(candidates, target, res, work, 0, 0);

        /*

            candidates -> source of truth

            target -> self explanatory

            res -> storage

            work -> mutable buffer

            i -> anything below this index ignored

            sum -> keeps track of sum of work gives O(1) access

        */

  

        return new ArrayList<List<Integer>>(res);

    }

  

    void helper(int[] candidates, int target, Set<List<Integer>> res, List<Integer> work, int i, int sum){

        //System.out.println(work);

  

        if(sum >= target){

            if(sum == target)

                res.add(new ArrayList<>(work));

            return;

        }

  

        for(int x=i; x<candidates.length; x++){

            // Pick

            work.add(candidates[x]);

  

            // Explore

            helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

            // Unpick

            work.remove(work.size()-1);

        }

    }

  

}
```

# Code
## My code:
```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target)    

    {

  

        List<List<Integer>> res = new ArrayList<>();

        List<Integer> work = new ArrayList<>();

        Arrays.sort(candidates);

        //System.out.println(Arrays.toString(candidates));

        helper(candidates, target, res, work, 0, 0);

        /*

            candidates -> source of truth

            target -> self explanatory

            res -> storage

            work -> mutable buffer

            i -> anything below this index ignored

            sum -> keeps track of sum of work gives O(1) access

        */

  

        return res;

    }

  

    void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> work, int i, int sum){

        //System.out.println(work);

  

        if(sum >= target){

            if(sum == target)

                res.add(new ArrayList<>(work));

            return;

        }

  

        for(int x=i; x<candidates.length; x++){

  

            //Core skipping thingy I learnt

            // Why not x>0 but x>i

            if(x>i && candidates[x] == candidates[x-1])

                continue;

  

            // Pick

            work.add(candidates[x]);

  

            // Explore

            helper(candidates, target, res, work, x+1, sum+candidates[x]);

  

            // Unpick

            work.remove(work.size()-1);

        }

    }

  

}
```