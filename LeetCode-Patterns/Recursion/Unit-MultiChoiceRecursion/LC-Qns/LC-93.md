# Drafts
## Draft1: i messed up the `i+x+1`
```java
class Solution {

Â  Â  public List<String> restoreIpAddresses(String s) {

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  List<List<Integer>> res = new ArrayList<>();

  

Â  Â  Â  Â  helper(s, work, res, 0, 4);

  

Â  Â  Â  Â  System.out.println(res);

Â  Â  Â  Â  return null;

Â  Â  }

  

Â  Â  void helper(String s, List<Integer> work, List<List<Integer>> res, int i, int k){

Â  Â  Â  Â  // Base Cases

Â  Â  Â  Â  if(i>=s.length()){

Â  Â  Â  Â  Â  Â  if(work.size() == k){

Â  Â  Â  Â  Â  Â  Â  Â  // Change to string here

Â  Â  Â  Â  Â  Â  Â  Â  res.add(new ArrayList<Integer>(work));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=0; x<3; x++){

Â  Â  Â  Â  Â  Â  if(i+x >= s.length()){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  String subs = s.substring(i, i+x+1);

Â  Â  Â  Â  Â  Â  //System.out.println(subs);

  

Â  Â  Â  Â  Â  Â  int num = Integer.parseInt(subs);

Â  Â  Â  Â  Â  Â  if(num > 255 || num < 0){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //Pick

Â  Â  Â  Â  Â  Â  work.add(num);

Â  Â  Â  Â  Â  Â  //Recurse

Â  Â  Â  Â  Â  Â  helper(s, work, res, i+x+1, k);

Â  Â  Â  Â  Â  Â  //Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

  

Â  Â  Â  Â  }

Â  Â  }

}
```
## Draft2: Some random logic error
```java
class Solution {

Â  Â  public List<String> restoreIpAddresses(String s) {

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  List<String> res = new ArrayList<>();

  

Â  Â  Â  Â  helper(s, work, res, 0, 4, new StringBuilder());

  

Â  Â  Â  Â  //System.out.println(res);

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  void helper(String s, List<Integer> work, List<String> res, int i, int k, StringBuilder buffer){

Â  Â  Â  Â  // Base Cases

Â  Â  Â  Â  if(i>=s.length()){

Â  Â  Â  Â  Â  Â  int sz = work.size();

Â  Â  Â  Â  Â  Â  if(sz == k){

Â  Â  Â  Â  Â  Â  Â  Â  // Change to string here

Â  Â  Â  Â  Â  Â  Â  Â  buffer.setLength(0);

Â  Â  Â  Â  Â  Â  Â  Â  for(int j=0; j<sz; j++){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffer.append(String.valueOf(work.get(j)));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(j != sz-1){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffer.append(".");

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  res.add(buffer.toString());

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=0; x<3; x++){

Â  Â  Â  Â  Â  Â  if(i+x >= s.length()){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  String subs = s.substring(i, i+x+1);

Â  Â  Â  Â  Â  Â  //System.out.println(subs);

  

Â  Â  Â  Â  Â  Â  int num = Integer.parseInt(subs);

Â  Â  Â  Â  Â  Â  if(num > 255 || num < 0){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //Pick

Â  Â  Â  Â  Â  Â  work.add(num);

Â  Â  Â  Â  Â  Â  //Recurse

Â  Â  Â  Â  Â  Â  helper(s, work, res, i+x+1, k, buffer);

Â  Â  Â  Â  Â  Â  //Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

  

Â  Â  Â  Â  }

Â  Â  }

}
```
# Code
## My Code:
```java
class Solution {

Â  Â  public List<String> restoreIpAddresses(String s) {

Â  Â  Â  Â  List<Integer> work = new ArrayList<>();

Â  Â  Â  Â  List<String> res = new ArrayList<>();

  

Â  Â  Â  Â  helper(s, work, res, 0, 4, new StringBuilder());

  

Â  Â  Â  Â  //System.out.println(res);

Â  Â  Â  Â  return res;

Â  Â  }

  

Â  Â  void helper(String s, List<Integer> work, List<String> res, int i, int k, StringBuilder buffer){

Â  Â  Â  Â  // Base Cases

Â  Â  Â  Â  if(i>=s.length()){

Â  Â  Â  Â  Â  Â  int sz = work.size();

Â  Â  Â  Â  Â  Â  if(sz == k){

Â  Â  Â  Â  Â  Â  Â  Â  // Change to string here

Â  Â  Â  Â  Â  Â  Â  Â  buffer.setLength(0);

Â  Â  Â  Â  Â  Â  Â  Â  for(int j=0; j<sz; j++){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffer.append(String.valueOf(work.get(j)));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(j != sz-1){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffer.append(".");

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  res.add(buffer.toString());

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int x=0; x<3; x++){

Â  Â  Â  Â  Â  Â  if(i+x >= s.length()){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  String subs = s.substring(i, i+x+1);

Â  Â  Â  Â  Â  Â  //System.out.println(subs);

Â  Â  Â  Â  Â  Â  if (subs.length() > 1 && subs.charAt(0) == '0') {

Â  Â  Â  Â  Â  Â  Â  Â  // we cant have stuff starting with 0

Â  Â  Â  Â  Â  Â  Â  Â  // Parse int cant handle it so come out early

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  int num = Integer.parseInt(subs);

Â  Â  Â  Â  Â  Â  if(num > 255 || num < 0){

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //Pick

Â  Â  Â  Â  Â  Â  work.add(num);

Â  Â  Â  Â  Â  Â  //Recurse

Â  Â  Â  Â  Â  Â  helper(s, work, res, i+x+1, k, buffer);

  

Â  Â  Â  Â  Â  Â  //Unpick

Â  Â  Â  Â  Â  Â  work.remove(work.size()-1);

  

Â  Â  Â  Â  }

Â  Â  }

}
```
## ğŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

---

### ğŸ§  1ï¸âƒ£ Mental Model vs Memorization

Your instinctive approach is visible everywhere in the drafts and comments:

- â€œTake 1â€“3 digitsâ€
    
- â€œConvert to intâ€
    
- â€œCheck constraintsâ€
    
- â€œRecurse forwardâ€
    

That instinct is reasonable because it mirrors how _humans_ read an IP address: chunk â†’ parse â†’ validate.

Where it quietly breaks is **assuming that numeric validity implies semantic validity**.

You were thinking:

> â€œIf `Integer.parseInt` succeeds and `â‰¤ 255`, this segment is valid.â€

The problem doesnâ€™t contradict that loudly â€” it contradicts it _silently_.

The decisive shift you made was not about backtracking at all.  
It was realizing that **some invalid states survive numeric parsing**.

Once you saw that `"01"` turning into `1` is _not_ a parse error, the rest collapsed naturally:

- Validation must happen **before** integer conversion
    
- Validity is a **string property first**, numeric property second
    

That single shift removes an entire class of ghosts.

---

### ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

This problem tempts people to label it:

- â€œBacktrackingâ€
    
- â€œDFSâ€
    
- â€œRecursion with pruningâ€
    

Those labels are not wrong â€” but they pull attention away from what _actually matters_ here.

Your own drafts show you werenâ€™t confused about recursion mechanics:

- You had pick / recurse / unpick from the start
    
- You tracked `i`
    
- You bounded segment length
    

What kept biting you was **violating an invariant without noticing**.

This is not â€œabout backtrackingâ€.  
Itâ€™s about **maintaining representation invariants across transformations**.

The moment you framed the segment as a _string with rules_, not an _int with bounds_, the label stopped mattering.

---

### ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

Each major decision in your final code follows directly from friction you hit earlier.

- **Using `i + x + 1`**
    
    - Draft1 shows you knew `x` was relative, not absolute
        
    - The bug wasnâ€™t confusion â€” it was a single missed offset
        
    - Once fixed, index flow stopped fighting you
        
- **Building the result only at the leaf**
    
    - You resisted early string construction
        
    - That avoided partial, misleading artifacts
        
    - It matches how you reasoned: _numbers first, format later_
        
- **Early exit on leading zero**
    
    - This wasnâ€™t a rule you memorized
        
    - It emerged because numeric parsing betrayed you
        
    - At that moment, continuing recursion started to feel dishonest
        

Nothing here is arbitrary.  
Each choice reduced tension between â€œwhat the code allowsâ€ and â€œwhat the problem meansâ€.

---

### ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why _Your_ Artifacts Matter

Your artifacts arenâ€™t noise â€” they block specific traps.

- **Comment: â€œi messed up the `i+x+1`â€**
    
    - Prevents the classic false belief that recursion bugs are conceptual
        
    - This was an indexing slip, not misunderstanding
        
- **Repeated use of `return`**
    
    - Shows you were thinking in monotonic constraints
        
    - Once a longer prefix is invalid, shorter ones already failed
        
    - That intuition turns out to be correct _for this problem_
        
- **Comment about `parseInt` not handling prefix 0**
    
    - This is the real turning point
        
    - It captures the moment you realized:
        
        > â€œThe language accepts something the problem rejectsâ€
        
    - That awareness is transferable
        

Once this clicks, alternative approaches (DP, memoization, over-pruning) stop making sense automatically.

---

## ğŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

---

### ğŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

The non-obvious part of your code is not recursion â€” itâ€™s **where validation happens**.

- You validate _substring shape_ **before** integer conversion
    
- You validate _numeric range_ **after**
    
- You only build output when:
    
    - string is exhausted
        
    - exactly 4 segments exist
        

This ordering mirrors your mental trust hierarchy:

> â€œIf the representation is wrong, donâ€™t even interpret it.â€

Thatâ€™s why the final version stabilizes.

---

### ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Draft1 (`i+x+1`)**
    
    - Thinking: â€œx already tracks how far I movedâ€
        
    - Reality: `x` is local length, not global position
        
    - The problem exposed this by looping forever
        
- **Draft2 (random logic errors)**
    
    - Thinking: â€œIf base cases exist, recursion will self-correctâ€
        
    - Reality: recursion happily explores invalid-but-legal states
        
- **Final bug (leading zero)**
    
    - Thinking: â€œParsing enforces correctnessâ€
        
    - Reality: parsing enforces _syntax_, not _semantics_
        

Each bug corresponds to trusting the wrong layer.

---

### ğŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

Your structure helps thinking because:

- `work` holds meaning, not formatting
    
- `buffer` is reset explicitly â€” no hidden state
    
- Formatting is isolated to one place
    

Flattening this (e.g., building strings incrementally) would blur:

- validation
    
- representation
    
- output
    

Mentally, that would make it harder to see _why_ something is invalid.

---

### ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

The one constraint that actually shapes everything here:

- **Segment validity is representation-dependent**
    

Constraints that look important but arenâ€™t decisive here:

- recursion depth
    
- performance (search space is tiny)
    
- memory reuse
    

Language-specific detail that mattered:

- Javaâ€™s `Integer.parseInt` accepts `"01"`
    
- The problem domain does not
    

If that single constraint changed (e.g., allowing `"01"`), your entire reasoning pipeline would simplify.

---

### ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern name:** _Validate before interpretation_

**Plain-language description:**

- When transforming data (string â†’ number),
    
- enforce domain rules **before** trusting the transformation.
    

**When this applies:**

- parsing dates
    
- IPs, versions, semantic tokens
    
- user input with formatting rules
    

**When it does not apply:**

- purely numeric problems where representation is irrelevant
    

**Mental note to reuse:**

> When a bug survives parsing, stop debugging logic â€” inspect representation.

---

You didnâ€™t â€œfinally get backtrackingâ€.  
You already had it.

You fixed a **representation invariant leak** â€” and thatâ€™s the kind of lesson that sticks.