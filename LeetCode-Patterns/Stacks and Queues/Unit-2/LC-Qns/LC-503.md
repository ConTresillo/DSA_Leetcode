# Drafts
## Draft1: I sorted later realised it destroys the relative positioning information
```java
class Solution {

    public int[] nextGreaterElements(int[] nums) {

        // I will try sorting

        // I need custom comparator that takes in indices and sorts by values

  

        /*

        Googled: Custom Comparator Syntax

        1) I can't Manually use Arrays.sort()

        2) Comparator class works for Interfaces ig not for Raw Arrays

        3) Convert to Array using .asList()

        4) Apply and return back

  

        5) I would rather create from Array from the scratch

  

        Collections.sort(C<E> collection, new Comparator<E>()

        {

            @Override

                public int compare(E e1, E e2) {

                    //return comparison logic e1 - e2 some way

                }

        }

        );

  

        */

  

        List<Integer> idx = new ArrayList<>();

        for(int i=0; i<nums.length; i++){

            idx.add(i);

        }

        //System.out.println(idx);

        Collections.sort(idx, new Comparator<Integer>(){

            @Override

                public int compare(Integer idx1, Integer idx2){

                    // We compare by their values

                    return nums[idx1] - nums[idx2];

                }

        }

        );

        //System.out.println(idx);

        // Works

  

        // Now apply the monotonic constraint here ig

        Deque<Integer> d = new ArrayDeque<>();

        for(int x : idx){

            //System.out.println(x);

            while(d.size() != 0 && d.peekLast()<nums[x]){

            }

        }

        return nums;

    }

}
```
## Draft2: For some reason Lapping didnt work
```java
class Solution {

    public int[] nextGreaterElements(int[] nums) {

        // Maybe i should iterate 2 times? ?

  

        // I can't overwrite array i will use seperate memory

        // I can't use encoding decoding too cus 10^9 is way big

        int[] res = new int[nums.length];

        for(int i=0; i<nums.length; i++){

            res[i] = -1;

        }

        int cnt = 0;

        // count the laps?

        Deque<Integer> stk = new ArrayDeque<>();

        // Let it store index

        for(int i=0; i<nums.length; i++){

            while(stk.size() != 0 && nums[stk.peekLast()] < nums[i]){

                int popped = stk.removeLast();

                if(res[popped] == -1)res[popped] = nums[i];

            }

            stk.addLast(i);

            // Question mistake?? -1 is in domain and also a sentinel value wtf

  

            if(i==nums.length-1 && cnt == 0){

                i = 0;

                cnt++;

            }

        }

        //System.out.println(Arrays.toString(res));

        return res;

    }

}
``` 
```java
Wrong Answer

146 / 223 testcases passed

Editorial

Input

nums =

[5,4,3,2,1]

Use Testcase

Output

[-1,-1,4,4,4]

Expected

[-1,5,5,5,5]
```
# Codes
## My Code
```java
class Solution {

    public int[] nextGreaterElements(int[] nums) {

        int n = nums.length;

        int[] res = new int[n];

        Arrays.fill(res, -1);

        Deque<Integer> stk = new ArrayDeque<>();

        for (int i = 0; i < n * 2; i++) {

            while (!stk.isEmpty() && nums[stk.peek()] < nums[i % n])

                res[stk.pop()] = nums[i % n];

            stk.push(i % n);

        }

        return res;

    }

}
```