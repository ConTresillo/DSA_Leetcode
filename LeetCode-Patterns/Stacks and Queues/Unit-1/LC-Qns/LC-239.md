# Drafts
## Draft1: I forgot that the comparison is within the Window not globally
I was lucky the test cases where monotonically increasing
```python
class Solution:

    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:

        # Setup vars

  

        n = len(nums)

        ## Idk does storing n optimise performance than calling len() ? u decide

  

        d = deque()

        ## Deque to simulate logic

        ## print(d)

  

        i = 0

        ## Iterator to traverse the array

  

        MAX = -float('inf')

        ## Standard way, use Integer.MIN_VALUE in JAVA

  

        Res = []

        ## List to hold stuff

  

        # Init the Sliding Window

        ## i=0 to k-1

        while i < k:

            ## Order doesn't matter here

            MAX = max(MAX,nums[i])

            d.append(nums[i])

  

            ## Next State

            i += 1

        ## print(MAX)

        Res.append(MAX)

  

        # Now do the Sliding Window (Fixed)

        ## i=3 to n-1

        while i < n:

            d.popleft()

            ## Queue takes care of the insertion and deletion elegantly

            d.append(nums[i])

            MAX = max(MAX, nums[i])

            ## Before u go to next state add the MAX to Res

            Res.append(MAX)

            i += 1

        return Res
```
# Codes
## Code1: This is unoptimised code which i wrote when solving Array Qns and blindly like in December 
```python
class Solution:
    def Append(self, Q, ind, nums):
        if len(Q) == 0:
            Q.append(ind)
            return 
        prev = len(Q)-1
        while len(Q)>0 and nums[Q[prev]] < nums[ind]: #Not len(Q)>=0 cus prev = -1  wrong
            Q.pop()
            prev = len(Q)-1
        Q.append(ind) #Just push the index
        return 

    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        Q = deque()
        i = 0
        n = len(nums)
        ans = []
        while i < n: #Iterate fully dont make premature windows like n+k-1
            self.Append(Q,i,nums)
            # replace your old expiry check with THIS
            if len(Q) > 0 and i >= Q[0] + k:
                Q.popleft()

            # 3️⃣ output when window is ready
            if i >= k - 1:
                ans.append(nums[Q[0]])
            i += 1

        return ans


```