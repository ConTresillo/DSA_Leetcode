# Drafts
## Draft1 : IDk
```java
class Solution {

Â  Â  public String removeDuplicates(String s) {

Â  Â  Â  Â  StringBuilder S = new StringBuilder();

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  S.append(s.charAt(i));

Â  Â  Â  Â  Â  Â  while(S.length()!=0 && s.charAt(i)==S.charAt(S.length() - 1)){

Â  Â  Â  Â  Â  Â  Â  Â  S.deleteCharAt(S.length()-1);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return S.toString();

Â  Â  }

}
```
## Draft2: Idk still
```java
class Solution {

Â  Â  public String removeDuplicates(String s) {

Â  Â  Â  Â  StringBuilder S = new StringBuilder();

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  while(S.length()!=0 && s.charAt(i)==S.charAt(S.length() - 1)){

Â  Â  Â  Â  Â  Â  Â  Â  S.deleteCharAt(S.length()-1);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  S.append(s.charAt(i));

Â  Â  Â  Â  }

Â  Â  Â  Â  return S.toString();

Â  Â  }

}
```
# Codes
## Code1
```java
class Solution {

Â  Â  public String removeDuplicates(String s) {

Â  Â  Â  Â  StringBuilder S = new StringBuilder();

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  if(S.length()!=0 && s.charAt(i)==S.charAt(S.length() - 1)){

Â  Â  Â  Â  Â  Â  Â  Â  S.deleteCharAt(S.length()-1);

Â  Â  Â  Â  Â  Â  Â  Â  continue;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  S.append(s.charAt(i));

Â  Â  Â  Â  }

Â  Â  Â  Â  return S.toString();

Â  Â  }

}
```
# ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

---

## 1ï¸âƒ£ Mental Model vs Memorization

Your instinct across all drafts is consistent:

- Treat `StringBuilder` like a stack.
    
- Compare current character with the â€œtopâ€.
    
- Cancel if equal.
    

That mental model is correct.

Where you struggled was not the idea â€” it was **timing of mutation**.

### Draft1 mistake

You appended first:

```java
S.append(...)
```

Then compared.

That silently changed the meaning of:

> â€œtop of stackâ€

It stopped meaning â€œprevious characterâ€  
and started meaning â€œthe one I just added.â€

So your mental model was:

> compare current with previous

But your execution did:

> compare current with current

Thatâ€™s a sequencing mismatch.

---

### Draft2 mistake

You fixed the ordering:

- Compare first
    
- Then append
    

But you used a `while`.

That means:

> If equal â†’ delete repeatedly  
> Then append anyway

So duplicates never truly cancel.

You removed the previous character â€” but then you re-added the current one unconditionally.

The mental shift needed here is subtle:

This problem is not:

> â€œKeep deleting while equal.â€

It is:

> â€œIf equal, cancel the pair.â€

Exactly one cancellation per character arrival.

No more. No less.

---

### Code1 (Correct Mental Alignment)

```java
if (match) {
    delete;
    continue;
}
append;
```

Now the structure mirrors the rule:

- If top equals current â†’ remove and stop.
    
- Else â†’ push.
    

This aligns mutation with decision.

Thatâ€™s why this version works.

---

## ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual)

People over-label this as:

- String manipulation
    
- Two pointers
    
- Repeated scanning
    

But the real invariant is simple:

> The builder always represents the fully reduced string up to index `i`.

That invariant collapses complexity.

At every step:

- The last character is the only one that can interact with the incoming character.
    

No need for:

- Nested loops
    
- Global scanning
    
- Reprocessing entire string
    

Itâ€™s purely local interaction.

---

## ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

### ðŸ”¹ Using `StringBuilder` as a stack

Natural consequence of the invariant:

- Only care about last processed character.
    
- Need fast append and delete-last.
    

Correct abstraction.

---

### ðŸ”¹ Switching from `while` to `if`

This is the conceptual correction.

Your `while` assumed:

> multiple deletions might be needed for one incoming character.

But thatâ€™s not how adjacency works.

Each incoming character can only cancel with:

- The immediate top.
    

If it cancels, it disappears.  
If it doesnâ€™t, it stays.

Thereâ€™s no cascading inside the same iteration.

Cascade only happens across iterations.

Thatâ€™s why `if` is correct.

---

## ðŸŸ¡ 4ï¸âƒ£ Why Your Drafts Matter

### Draft1 shows:

You understood cancellation,  
but mutation happened too early.

This is a sequencing discipline issue.

---

### Draft2 shows:

You sensed the need to check before appending,  
but over-generalized the removal logic.

Thatâ€™s a â€œmechanical overcorrectionâ€ â€” common when debugging.

---

### Code1 shows:

You internalized the invariant:

> One arrival â†’ at most one cancellation.

And structured the control flow around it.

Thatâ€™s the clean mental model.

---

# ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

---

## ðŸŸ£ 5ï¸âƒ£ Algorithm Walkthrough (Intent Only)

For each character:

1. If stack not empty AND top equals current:
    
    - Remove top.
        
    - Skip append.
        
2. Otherwise:
    
    - Append.
        

Final builder = fully reduced string.

The `continue` is not stylistic â€”  
it enforces the â€œcancel or appendâ€ exclusivity.

---

## ðŸ”´ 6ï¸âƒ£ Error Analysis (Thinking-Level)

### Core confusion

You mixed two different interpretations:

- â€œRepeated deletionâ€
    
- â€œPair cancellationâ€
    

The problem is pair cancellation.

Not repeated deletion per character.

The `while` structure reflected the wrong mental framing.

---

## ðŸŸ£ 7ï¸âƒ£ Code Structure & Cognitive Clarity

The final version:

```java
if (match) {
    delete;
    continue;
}
append;
```

This structure makes the state machine explicit:

- Two mutually exclusive outcomes.
    
- No double mutation.
    
- No accidental re-addition.
    

Flattening this would blur that separation.

---

## ðŸ”µ 8ï¸âƒ£ Real Constraint That Shapes Everything

The critical constraint:

> Only adjacent duplicates cancel.

Because of that:

- Only the last character matters.
    
- Stack depth beyond top is irrelevant at decision time.
    

If cancellation were non-adjacent,  
this whole approach would fail.

---

## ðŸ§© 9ï¸âƒ£ Pattern Extraction

**Pattern:** Local Pair Cancellation via Stack

Reusable mental rule:

> When elements cancel only with their immediate predecessor, maintain a stack of processed results.

And the practical discipline:

> Never mutate state before deciding whether the mutation should exist.

Thatâ€™s the core lesson across your drafts.