# Code
```java
class Solution {
    public int firstUniqChar(String s) {
        Map<Character,Integer> map = new HashMap<>();

        for(int i=0; i<s.length(); i++){
            char c = s.charAt(i);
            map.put(c,map.getOrDefault(c,0)+1);
        }

        int ans = Integer.MAX_VALUE;

        for(int i=0; i<s.length(); i++){
            if(map.get(s.charAt(i)) == 1){
                ans = Math.min(ans,i);
            }
        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

}
```
# ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

## 1ï¸âƒ£ Mental Model vs Memorization

- The most common instinct with _Majority Element_ is:
    
    - â€œCount frequencies.â€
        
    - Or â€œSort and pick the middle.â€
        
- That feels reasonable because _majority_ sounds like a **numerical property**.  
    You instinctively reach for counting tools.
    
- Where this quietly goes wrong:
    
    - You start treating the problem as _measurement_, when itâ€™s really about **survival under opposition**.
        
    - You solve it, but you donâ€™t understand _why_ a simpler approach works.
        
- The small shift that helps:
    
    - Stop thinking of majority as â€œappears more than n/2 timesâ€.
        
    - Start thinking of it as **the only value that cannot be fully canceled out**.
        
- Once you see the problem as _pairwise cancellation_, the algorithm stops feeling magical.  
    The majority element doesnâ€™t win because itâ€™s counted â€” it wins because **it outlasts everyone else**.
    

---

## ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Label-Based)

- People rush to label this as:
    
    - â€œArray problemâ€
        
    - â€œGreedy algorithmâ€
        
- These labels arenâ€™t wrong, but they hide the real idea.
    
- A better framing:
    
    - Every time two different elements meet, they neutralize each other.
        
    - Only something with **excess presence** can survive all neutralizations.
        
- The problem is less about arrays and more about **conflict resolution over time**.
    

---

## ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Decision: Track one candidate and one counter**
    
    - The problem demands only one survivor, not a full census.
        
- **Tempting alternative: Track everyoneâ€™s count**
    
    - Feels safe.
        
    - Starts to feel wasteful because most elements donâ€™t matter once canceled.
        
- **Decision: Reset candidate when count hits zero**
    
    - This isnâ€™t a trick â€” itâ€™s acknowledging that the current candidate has lost all influence.
        
- **Tempting alternative: Keep the old candidate anyway**
    
    - Feels loyal.
        
    - Breaks down because a candidate with zero support is meaningless.
        

---

## ðŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts and How _Your_ Artifacts Help Avoid Mistakes

Using only what you provided:

- **Your â€œhat holderâ€ analogy**
    
    - Keeps you from thinking the algorithm is about dominance at every step.
        
    - This confusion is common because people expect the majority to always look strong.
        
    - The analogy matters exactly when `count` drops to zero.
        
- **Your comment: â€œjust an algorithm once you remember itâ€**
    
    - Signals a danger point: memorization without understanding.
        
    - The analogy reframes it as a _process_, not a formula.
        
- **The one-vs-many framing**
    
    - Prevents the mistake of assuming early elements matter more than later ones.
        
    - Everyone gets challenged equally.
        

### Insight Compression

> Once you see majority as something that _survives cancellation_, counting-based solutions quietly stop feeling like the right mental model â€” which is why the logic collapses into something so small.

---

# ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

## 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

Referring to your **Code** section:

- **`majority` variable**
    
    - Represents the current survivor of all conflicts so far.
        
    - If this were removed, the algorithm would lose identity.
        
- **`count` variable**
    
    - Tracks remaining â€œpowerâ€ after clashes.
        
    - Without it, you couldnâ€™t detect when a candidate has been neutralized.
        
- **Reset when `count == 0`**
    
    - This is the handover moment in your hat-holder analogy.
        
    - If skipped, a defeated candidate would incorrectly persist.
        

---

## ðŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Bug tendency: Thinking the current candidate is always the answer**
    
    - Thought process: â€œItâ€™s called majority, so it should stay dominant.â€
        
    - Feels intuitive.
        
    - The problem exposes that dominance is _temporary_ until proven durable.
        
- **Bug tendency: Assuming early values are more important**
    
    - Thought process: â€œThe first element starts as majority.â€
        
    - Feels natural because initialization biases perception.
        
    - The algorithm deliberately allows later elements to overthrow early ones.
        

These arenâ€™t implementation mistakes â€” theyâ€™re intuition mismatches.

---

## ðŸŸ£ 7ï¸âƒ£ Code Structure Review

- The structure mirrors the story:
    
    - one candidate â†’ repeated challenges â†’ possible dethroning â†’ eventual survivor.
        
- This makes it easy to reason about correctness without tracking frequencies.
    
- Flattening the logic would hide the â€œtransfer of powerâ€ moment.
    

---

## ðŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs

- The constraint that actually shapes the solution:
    
    - **A majority element is guaranteed to exist**.
        
- Constraints that look important but donâ€™t matter:
    
    - Exact counts
        
    - Positions of elements
        
- If the guarantee were removed, the _thinking_ would change â€” youâ€™d need a verification pass, not a different loop.
    

---

## ðŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

- **Plain-language pattern:**
    
    - â€œRepeated cancellation reveals the dominant survivor.â€
        
- **Useful when:**
    
    - One element must overpower all others combined.
        
- **Different-looking example where it applies:**
    
    - Finding an element that appears more than half the time in a vote stream.
        
- **Where it doesnâ€™t apply:**
    
    - Problems where multiple winners can exist or no winner is guaranteed.
        

**Mental note:**

> If something must outnumber everything else combined, try canceling conflicts instead of counting them.