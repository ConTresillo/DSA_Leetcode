# Draft 1: Counting Sort gone Wrong!
```java
//Past Debacle
class Solution {

Â  Â  /*static class Pair{

Â  Â  Â  Â  char alph;

Â  Â  Â  Â  int freq;

  

Â  Â  Â  Â  Pair(){

Â  Â  Â  Â  Â  Â  alph = '\0';

Â  Â  Â  Â  Â  Â  freq = -1;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  Pair(char alph, int freq){

Â  Â  Â  Â  Â  Â  this.alph = alph;

Â  Â  Â  Â  Â  Â  this.freq = freq;

Â  Â  Â  Â  }

Â  Â  }*/

Â  Â  //I rejected Pair cus i can't have O(1) lookup while counting freq

Â  Â  public String frequencySort(String s) {

Â  Â  Â  Â  //Pair obj = new Pair(); Test syntax

Â  Â  Â  Â  //THis is just normal counting sort

Â  Â  Â  Â  //Idk why i got stuck

Â  Â  Â  Â  //Why i overthinking and shi

Â  Â  Â  Â  //Just apply the freaking algorithm and thts it

Â  Â  Â  Â  //Once u sort the Array of Pairs then iterate from back to reconstruct

Â  Â  Â  Â  //EZ af idk why i struggled for 2 hrs

  

Â  Â  Â  Â  //Idk how to sort if they add constraint like alphabetic if equal bruh im cooked

Â  Â  Â  Â  //Turn string into Pair array

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  //Pair[] arr = new Pair[n]; //Worst case atmost n possible

Â  Â  Â  Â  Map<Character,Integer> freqMap = new HashMap<>();

  

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  freqMap.put(s.charAt(i), freqMap.getOrDefault(s.charAt(i), 0)+1);

Â  Â  Â  Â  Â  Â  //Increment the count;

Â  Â  Â  Â  }

Â  Â  Â  Â  int max = -1;

Â  Â  Â  Â  for(int v : freqMap.values()){

Â  Â  Â  Â  Â  Â  //System.out.println(entry.getValue());

Â  Â  Â  Â  Â  Â  max = Math.max(max,v);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  //System.out.println(max);

Â  Â  Â  Â  //Make index Arr

Â  Â  Â  Â  int[] index = new int[max+1];

  

Â  Â  Â  Â  for(int v : freqMap.values()){

Â  Â  Â  Â  Â  Â  //System.out.println(v);

Â  Â  Â  Â  Â  Â  index[v]++;

Â  Â  Â  Â  }

Â  Â  Â  Â  /*for(int v : index){

Â  Â  Â  Â  Â  Â  System.out.println(v);

Â  Â  Â  Â  }*/

  

Â  Â  Â  Â  //Cumulative sum

Â  Â  Â  Â  for(int i=max-1; i>0; i--){

Â  Â  Â  Â  Â  Â  index[i] = index[i] + index[i+1];

Â  Â  Â  Â  Â  Â  //System.out.println(index[i]);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int v : index){

Â  Â  Â  Â  Â  Â  System.out.println(v);

Â  Â  Â  Â  }

Â  Â  Â  Â  //I did in reverse cus wat i want to achieve is the opposite

Â  Â  Â  Â  //im still confused about the entire proceedure

Â  Â  Â  Â  //I dont get wat im doing !!!!! Somehow it works

  
  

  

Â  Â  Â  Â  //Boilerplate ready now apply it

Â  Â  Â  Â  char[] buf = new char[n];

Â  Â  Â  Â  //Get index from index

Â  Â  Â  Â  //Get loop count from pair.freq

  

Â  Â  Â  Â  //Iterate from back for some reason

Â  Â  Â  Â  //Literally im cargoculting i hate it

Â  Â  Â  Â  for(char c : freqMap.keySet()){

Â  Â  Â  Â  Â  Â  int k = freqMap.get(c);

Â  Â  Â  Â  Â  Â  System.out.println(c + " : " + Â index[k]);

Â  Â  Â  Â  Â  Â  //Maybe place then decrement?

Â  Â  Â  Â  Â  Â  //Usually we decrement then place idk its so confusing

Â  Â  Â  Â  Â  Â  buf[index[k]] = c;

Â  Â  Â  Â  Â  Â  index[k] = index[k]-1;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  System.out.println(new String(buf));

  
  

Â  Â  Â  Â  return new String(); //Don't interfere

Â  Â  }

}
```

# Draft 2: MLE with Raw Arrays!
```java
//Memory limit Exceeded
class Solution {

Â  Â  void printArr(int[] arr, int n){

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  System.out.println(arr[i]);

Â  Â  Â  Â  }

Â  Â  }

Â  Â  public String frequencySort(String s) {

Â  Â  Â  Â  int f = 128;

Â  Â  Â  Â  int[] freqArr = new int[f];

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  int max = -1;

Â  Â  Â  Â  int ind = -1;

Â  Â  Â  Â  int k = -1;

Â  Â  Â  Â  //Step 1

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  ind = (int)s.charAt(i);

Â  Â  Â  Â  Â  Â  freqArr[ind]++;

Â  Â  Â  Â  Â  Â  max = Math.max(freqArr[ind],max);

Â  Â  Â  Â  }

Â  Â  Â  Â  //printArr(freqArr, f);

  

Â  Â  Â  Â  //Step 2

Â  Â  Â  Â  //System.out.print(max);

Â  Â  Â  Â  int[][] bkt = new int[max+1][];

Â  Â  Â  Â  int b = max+1;

Â  Â  Â  Â  //0 to max we have here

Â  Â  Â  Â  //0 ignored 1 to max yes

Â  Â  Â  Â  for(int i=0; i<b; i++){

Â  Â  Â  Â  Â  Â  //Max we have n in a bucket

Â  Â  Â  Â  Â  Â  //I didn't use ArrayList cus i think it might be slower

Â  Â  Â  Â  Â  Â  //I'm just using primitives and not collections

Â  Â  Â  Â  Â  Â  //Cus im scared of using it because of its speed

Â  Â  Â  Â  Â  Â  //This is why ppl use Cpp ig lol

Â  Â  Â  Â  Â  Â  //They have such great lives

Â  Â  Â  Â  Â  Â  bkt[i] = new int[n+1];

Â  Â  Â  Â  Â  Â  //keep index 0 for actual length

Â  Â  Â  Â  }

Â  Â  Â  Â  //System.out.println(bkt[1]);

  

Â  Â  Â  Â  //Step3

Â  Â  Â  Â  //Now iterate the freqArr and but into respective buckets

Â  Â  Â  Â  for(int i=0; i<f; i++){

Â  Â  Â  Â  Â  Â  if (freqArr[i] > 0){

Â  Â  Â  Â  Â  Â  Â  Â  ind = freqArr[i];

Â  Â  Â  Â  Â  Â  Â  Â  k = ++bkt[ind][0];

Â  Â  Â  Â  Â  Â  Â  Â  bkt[ind][k] = i;

Â  Â  Â  Â  Â  Â  Â  Â  //System.out.println((char)bkt[ind][k] + " : " + ind);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

  

Â  Â  Â  Â  StringBuilder res = new StringBuilder();

  

Â  Â  Â  Â  for(int i=b-1; i>0; i--){

Â  Â  Â  Â  Â  Â  //System.out.println(i + " : " + bkt[i][0]);

  

Â  Â  Â  Â  Â  Â  for(int j=1; j<(bkt[i][0]+1); j++){

Â  Â  Â  Â  Â  Â  Â  Â  //System.out.println((char)bkt[i][j]);

  

Â  Â  Â  Â  Â  Â  Â  Â  for(int m=0; m<i; m++){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //System.out.print((char)bkt[i][j]);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res.append((char)bkt[i][j]);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  //System.out.println(" ");

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return res.toString();

Â  Â  }

}
```

# Code:
```java
//Finally Done
class Solution {

Â  Â  void printArr(int[] arr, int n){

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  System.out.println(arr[i]);

Â  Â  Â  Â  }

Â  Â  }

Â  Â  public String frequencySort(String s) {

Â  Â  Â  Â  int f = 128;

Â  Â  Â  Â  int[] freqArr = new int[f];

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  int max = -1;

Â  Â  Â  Â  int ind = -1;

Â  Â  Â  Â  int k = -1;

Â  Â  Â  Â  //Step 1

Â  Â  Â  Â  for(int i=0; i<n; i++){

Â  Â  Â  Â  Â  Â  ind = (int)s.charAt(i);

Â  Â  Â  Â  Â  Â  freqArr[ind]++;

Â  Â  Â  Â  Â  Â  max = Math.max(freqArr[ind],max);

Â  Â  Â  Â  }

Â  Â  Â  Â  //printArr(freqArr, f);

  

Â  Â  Â  Â  //ArrayList makes it so much easier

Â  Â  Â  Â  List<List<Character>> bkt = new ArrayList<>(max+1);

Â  Â  Â  Â  for (int i = 0; i < max+1; i++) {

Â  Â  Â  Â  Â  Â  bkt.add(new ArrayList<>());

Â  Â  Â  Â  }

Â  Â  Â  Â  for (int i=0; i<f; i++){

Â  Â  Â  Â  Â  Â  if(freqArr[i] > 0){

Â  Â  Â  Â  Â  Â  Â  Â  ind = freqArr[i];

Â  Â  Â  Â  Â  Â  Â  Â  bkt.get(ind).add((char)i);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

  

Â  Â  Â  Â  StringBuilder res = new StringBuilder();

  

Â  Â  Â  Â  for(int i=max; i>0; i--){

Â  Â  Â  Â  Â  Â  //System.out.println(bkt.get(i));

Â  Â  Â  Â  Â  Â  for(char c : bkt.get(i)){

Â  Â  Â  Â  Â  Â  Â  Â  //System.out.println(c + " : " + i);

Â  Â  Â  Â  Â  Â  Â  Â  for(int j=0; j<i; j++){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res.append(c);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return res.toString();

Â  Â  }

}
```

![Image](https://deen3evddmddt.cloudfront.net/uploads/content-images/bucket-sort.webp)

![Image](https://opensource.com/sites/default/files/lead-images/BIZ_DebucketizeOrgChart_A.png)

![Image](https://techlarry.github.io/Algorithm/%E5%85%B6%E4%BB%96/figures/bucketSort.png)

# ğŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

## 1ï¸âƒ£ Mental Model vs Memorization

- The instinctive way to see **frequency sort** is:  
    â€œThis is a sorting problem. I need to _sort characters_ somehow.â€
    
- That feels reasonable because the word _sort_ is right there in the title.  
    Your early attempts show this clearly: you reached for **pairs**, **indices**, **cumulative sums**, and full **counting sort ceremony**.
    
- Where this quietly goes wrong:
    
    - Sorting suggests **exact positions** matter.
        
    - But this problem never asks _where_ a character goes â€” only **how many times it repeats relative to others**.
        
- The small shift that unlocks everything:
    
    - Stop thinking in terms of _placing characters_.
        
    - Start thinking in terms of **building blocks of repetition**.
        
- Once you see the output as **blocks stacked by frequency**, not a finely ordered sequence, the problem stops feeling slippery.  
    Youâ€™re no longer arranging â€” youâ€™re **assembling**.
    

---

## ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Label-Based)

- People rush to label this as:
    
    - â€œCounting sort problemâ€
        
    - â€œHashing problemâ€
        
- Those labels pull attention toward **algorithms**, not **requirements**.
    
- A more accurate framing is:
    
    - Characters belong to **frequency groups**.
        
    - Higher-frequency groups must appear earlier.
        
    - Order _inside_ a group is irrelevant.
        
- Seen this way, the task is about **grouping + reconstruction**, not sorting in the traditional sense.
    

---

## ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Decision: Count frequencies first**
    
    - The problem demands global knowledge: how often each character appears.
        
- **Tempting alternative: Decide placement while scanning**
    
    - Feels efficient.
        
    - Breaks down because frequency isnâ€™t final until the scan is done.
        

---

- **Decision: Buckets indexed by frequency**
    
    - Frequency itself is small and bounded (`â‰¤ n`).
        
    - Each bucket represents _identity_, not repetition.
        
- **Tempting alternative: Index-based counting sort**
    
    - Feels algorithmically â€œcorrectâ€.
        
    - Starts to feel awkward because youâ€™re solving a stronger problem than required.
        

---

## ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts and How _Your_ Artifacts Help Avoid Mistakes

Using only what you provided:

- **Your handwritten breakdown (ASCII range, freq â†’ bucket)**
    
    - Keeps you from overfitting to alphabet-only assumptions.
        
    - This matters exactly when you chose `128` instead of `26`.
        
- **The â€œPast Debacleâ€ code with cumulative sums**
    
    - Shows the moment where intent and mechanism diverged.
        
    - This artifact keeps you from accidentally thinking confusion = lack of understanding.
        
- **The MLE version with `int[max+1][n+1]`**
    
    - Makes the space mistake visible: allocating by _imagined worst case_ instead of _true invariant_.
        
    - This confusion is common when learning bucket techniques.
        
- **The final solution**
    
    - Anchors the correct invariant: buckets store **distinct characters**, not repetitions.
        

### Insight Compression

> Once you start thinking in terms of _frequency blocks instead of index placement_, a whole set of heavy sorting machinery quietly stops making sense â€” which is why the solution narrows down so quickly.

---

# ğŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

## 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

Referring to your **final code**:

- **Frequency array (`freqArr[128]`)**
    
    - Exists to establish global truth about the string.
        
    - If skipped, later grouping would rely on guesses.
        
- **`max` frequency tracking**
    
    - Defines how many bucket layers are actually needed.
        
    - Without it, youâ€™d either over-allocate or miss the highest block.
        
- **`List<List<Character>> bkt`**
    
    - Each index = frequency.
        
    - Each list = characters that share that frequency.
        
    - This aligns storage with the problemâ€™s real invariant.
        
- **Reconstruction loop from `max â†’ 1`**
    
    - Enforces descending frequency naturally.
        
    - Repetition happens here â€” where it belongs.
        

---

## ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Bug: Full counting sort with cumulative sums**
    
    - Thought process: â€œSorting needs indices.â€
        
    - Feels reasonable if you associate sorting with placement.
        
    - The problem exposes that placement precision is unnecessary.
        
- **Bug: `int[max+1][n+1]` buckets (MLE)**
    
    - Thought process: â€œEach bucket might need space for `n`.â€
        
    - Feels safe.
        
    - Breaks because total distinct characters are bounded â€” not per bucket.
        

These werenâ€™t careless mistakes; they were **over-strong assumptions**.

---

## ğŸŸ£ 7ï¸âƒ£ Code Structure Review

- The final structure mirrors human reasoning:
    
    - learn frequencies
        
    - group identities
        
    - rebuild output
        
- This makes correctness easy to explain and debug.
    
- Flattening everything into index arithmetic would hide the intent again.
    

---

## ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs

- The constraint that actually shapes the solution:
    
    - **Distinct characters are bounded (ASCII)**.
        
- Constraints that look important but donâ€™t matter:
    
    - Relative order of equal-frequency characters
        
    - Exact index placement
        
- If the character set were unbounded, the _thinking_ would stay the same â€” only the container would change.
    

---

## ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

- **Plain-language pattern:**
    
    - â€œGroup by strength, then stack groups from strongest to weakest.â€
        
- **Useful when:**
    
    - Output consists of repeated blocks
        
    - Internal order doesnâ€™t matter
        
- **Different-looking example where it applies:**
    
    - Top-K frequent elements using buckets.
        
- **Where it doesnâ€™t apply:**
    
    - Problems requiring stable or lexicographically ordered output.
        

**Mental note:**

> When output is made of repeated blocks, store identities once and expand them only at reconstruction time.