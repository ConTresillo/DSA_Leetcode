## Errors I Faced

```java
Line 65: error: incompatible types: int cannot be converted to boolean boolean flag = 1; ^ Line 71: error: incompatible types: int cannot be converted to boolean flag = 0; ^ Line 82: error: incompatible types: int cannot be converted to boolean boolean isAnagram = 1; //Idk why default is 1 somehow i just keep it and it works ^ Line 83: error: incomparable types: boolean and int if(flag == 1){ //Handles overpowered p ^ Line 86: error: incompatible types: int cannot be converted to boolean isAnagram = 0; ^ 5 errors
```
``
```java
java.lang.StringIndexOutOfBoundsException: Index 10 out of bounds for length 10 at line 55, java.base/jdk.internal.util.Preconditions$1.apply at line 52, java.base/jdk.internal.util.Preconditions$1.apply at line 213, java.base/jdk.internal.util.Preconditions$4.apply at line 210, java.base/jdk.internal.util.Preconditions$4.apply at line 98, java.base/jdk.internal.util.Preconditions.outOfBounds at line 106, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex at line 302, java.base/jdk.internal.util.Preconditions.checkIndex at line 4904, java.base/java.lang.String.checkIndex at line 45, java.base/java.lang.StringLatin1.charAt at line 1624, java.base/java.lang.String.charAt at line 15, Solution.findAnagrams at line 56, __DriverSolution__.__helper__ at line 89, __Driver__.main
```
## Drafts
### Draft1:
```java
class Solution {

Â  Â  /*void inc(int[] arr){

Â  Â  Â  Â  for(int i=0; i<arr.length; i++){

Â  Â  Â  Â  Â  Â  arr[i]++;

Â  Â  Â  Â  }

Â  Â  }*/

  

Â  Â  void encode(int[] arr){

Â  Â  Â  Â  for(int i=0; i<arr.length; i++){

Â  Â  Â  Â  Â  Â  arr[i] = arr[i] * 100000 + arr[i];

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  void decode(int[] arr){

Â  Â  Â  Â  for(int i=0; i<arr.length; i++){

Â  Â  Â  Â  Â  Â  arr[i] = arr[i] / 100000;

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  public List<Integer> findAnagrams(String s, String p) {

Â  Â  Â  Â  //Make a container to store indices

Â  Â  Â  Â  List<Integer> res = new ArrayList<>();

  

Â  Â  Â  Â  //set up indice runner and window size

Â  Â  Â  Â  int i = 0;

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  int k = p.length();

Â  Â  Â  Â  if(n < k) return res;

  

Â  Â  Â  Â  //Create a 26 member hash domain restricted

Â  Â  Â  Â  int[] map = new int[26];

  

Â  Â  Â  Â  //Do an initial window run

Â  Â  Â  Â  while(i<k){

Â  Â  Â  Â  Â  Â  map[s.charAt(i) - 'a']++;

Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  }

Â  Â  Â  Â  //System.out.println(Arrays.toString(map));

Â  Â  Â  Â  //System.out.println(i);

Â  Â  Â  Â  //I can make another array and compare

Â  Â  Â  Â  //Or I can encode and decode

  

Â  Â  Â  Â  //I need to encode and decode for inplace cus it destroys the window

Â  Â  Â  Â  //Idk if its the required way but i think of this approach

Â  Â  Â  Â  //Im pretty sure theres another better way out there

  

Â  Â  Â  Â  //30000 so this is the worst case

Â  Â  Â  Â  //I require 5 digits for this

Â  Â  Â  Â  //Encode(30000) = 3000030000 = 30000 * 10000 + 30000

Â  Â  Â  Â  //Decode(3000030000) = ?

Â  Â  Â  Â  //(30000)30000 / 10000 = 300000

Â  Â  Â  Â  //30000(30000) % 10000 = 300000

Â  Â  Â  Â  //We get anagram if 30000(00000) % 10000 = 0,

Â  Â  Â  Â  //cus the lower 5 digits is used for current

Â  Â  Â  Â  //upper 5 digits is for reconstruction

  

Â  Â  Â  Â  //inc(map); Demo to check if i can mutate arr

Â  Â  Â  Â  //Yep i can

Â  Â  Â  Â  //System.out.println(Arrays.toString(map));

  

Â  Â  Â  Â  //System.out.println(Arrays.toString(map));

Â  Â  Â  Â  //Oh shit i figured out when this encode decode doesnt work

Â  Â  Â  Â  //If it goes lesser than 100000 then its fked up

Â  Â  Â  Â  //Ive to handle it seperately

Â  Â  Â  Â  boolean flag = true;

Â  Â  Â  Â  encode(map);

Â  Â  Â  Â  for(int j=0; j<k; j++){

Â  Â  Â  Â  Â  Â  //System.out.println(p.charAt(j));

Â  Â  Â  Â  Â  Â  if(--map[p.charAt(j) - 'a'] < 100000){

Â  Â  Â  Â  Â  Â  Â  Â  map[p.charAt(j) - 'a']++;

Â  Â  Â  Â  Â  Â  Â  Â  flag = false;

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  //Idk why im thinking like this lol somehow it just works

Â  Â  Â  Â  //System.out.println(Arrays.toString(map)); yep i get 0

Â  Â  Â  Â  //check only if boolean flag is true tht is worth validating

Â  Â  Â  Â  //Now a strong invariant tht i cant have anything lesser than 100000

Â  Â  Â  Â  //I believe i can simplify the above logic with Math.min() ?? maybe

Â  Â  Â  Â  //First i will work on this

Â  Â  Â  Â  boolean isAnagram = true; //Idk why default is 1 somehow i just keep it and it works

Â  Â  Â  Â  if(flag == true){ //Handles overpowered p

Â  Â  Â  Â  Â  Â  for(int j=0; j<26; j++){

Â  Â  Â  Â  Â  Â  Â  Â  if(map[i] % 100000 != 0) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAnagram = false;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  //If not 0 then obv nope handles powerless p

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //It's a shame i dont have python style for else block i have to simulate with flags

Â  Â  Â  Â  }

Â  Â  Â  Â  if(flag == true && isAnagram == true){

Â  Â  Â  Â  Â  Â  res.add(i-k); //i-k for some reason lol

Â  Â  Â  Â  }

Â  Â  Â  Â  decode(map);

Â  Â  Â  Â  //System.out.println(Arrays.toString(map));

Â  Â  Â  Â  //Producer Consumer also i can use

Â  Â  Â  Â  //We got window ready not just run it i till n-3 times

Â  Â  Â  Â  while(i<=n-k+1){

Â  Â  Â  Â  Â  Â  //flush out i-k

Â  Â  Â  Â  Â  Â  map[s.charAt(i-k) - 'a']--;

  

Â  Â  Â  Â  Â  Â  //add the ith member

Â  Â  Â  Â  Â  Â  map[s.charAt(i)- 'a']++;

  

Â  Â  Â  Â  Â  Â  encode(map);

Â  Â  Â  Â  Â  Â  flag = true;

Â  Â  Â  Â  Â  Â  for(int j=0; j<k; j++){

Â  Â  Â  Â  Â  Â  Â  Â  //System.out.println(p.charAt(j));

Â  Â  Â  Â  Â  Â  Â  Â  if(--map[p.charAt(j) - 'a'] < 100000){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map[p.charAt(j) - 'a']++;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  flag = false;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  isAnagram = true;

Â  Â  Â  Â  Â  Â  if(flag == true){ //Handles overpowered p

Â  Â  Â  Â  Â  Â  Â  Â  for(int j=0; j<26; j++){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(map[i] % 100000 != 0) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAnagram = false;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //If not 0 then obv nope handles powerless p

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //It's a shame i dont have python style for else block i have to simulate with flags

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if(flag == true && isAnagram == true){

Â  Â  Â  Â  Â  Â  Â  Â  res.add(i-k+1); //i-k for some reason lol

Â  Â  Â  Â  Â  Â  Â  Â  //i-k+1 works but i-k doesnt idk how

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  decode(map);

  
  

Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  }

  
  

Â  Â  Â  Â  return res;

Â  Â  }

}
```

```java
### Wrong Answer

60 / 65Â testcases passed

Editorial

Input

sÂ =

"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

View more

pÂ =

"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

View more

Use Testcase

Output

[0]

Expected

[0,10001]
```

## Code

```java
class Solution {

Â  Â  public List<Integer> findAnagrams(String s, String p) {

Â  Â  Â  Â  int[] mapS = new int[26];

Â  Â  Â  Â  int[] mapP = new int[26];

Â  Â  Â  Â  int n = s.length();

Â  Â  Â  Â  int k = p.length();

Â  Â  Â  Â  List<Integer> l = new ArrayList<>();

Â  Â  Â  Â  if(k > n) return l; //Some edge case bruh

Â  Â  Â  Â  for(int i=0; i<k; i++){

Â  Â  Â  Â  Â  Â  mapP[p.charAt(i)-'a']++;

Â  Â  Â  Â  }

Â  Â  Â  Â  //System.out.println(Arrays.toString(mapP));

  

Â  Â  Â  Â  for(int i=0; i<k; i++){

Â  Â  Â  Â  Â  Â  mapS[s.charAt(i)-'a']++;

Â  Â  Â  Â  }

Â  Â  Â  Â  //System.out.println(Arrays.toString(mapP));

Â  Â  Â  Â  boolean flag = true;

Â  Â  Â  Â  for(int i=0; i<26; i++){

Â  Â  Â  Â  Â  Â  if(mapS[i] != mapP[i]){

Â  Â  Â  Â  Â  Â  Â  Â  flag = false;

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  if(flag == true){

Â  Â  Â  Â  Â  Â  l.add(0);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int i=k; i<n; i++){

Â  Â  Â  Â  Â  Â  flag = true;

Â  Â  Â  Â  Â  Â  mapS[s.charAt(i-k)-'a']--;

Â  Â  Â  Â  Â  Â  mapS[s.charAt(i)-'a']++;

Â  Â  Â  Â  Â  Â  for(int j=0; j<26; j++){

Â  Â  Â  Â  Â  Â  if(mapS[j] != mapP[j]){

Â  Â  Â  Â  Â  Â  Â  Â  flag = false;

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if(flag == true){

Â  Â  Â  Â  Â  Â  Â  Â  l.add(i-k+1);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return l;

Â  Â  }

}
```

## ğŸŒ± Learning Summary

---

## ğŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ğŸ§  1ï¸âƒ£ Mental Model vs Memorization

**The instinctive approach**

- â€œAn anagram means same characters â†’ I need to _check equality_.â€
    
- That instinct pushes you toward:
    
    - Encoding tricks
        
    - Rebuilding counts every time
        
    - Or mutating arrays and trying to restore them later
        

This feels reasonable because the word _anagram_ suggests a **static comparison**.

**Where it quietly breaks**

- The problem is not asking:
    
    - â€œAre these two strings anagrams?â€
        
- It is asking:
    
    - â€œAs I move one step to the right, what _changed_?â€
        

Static thinking leads to:

- Encode/decode attempts
    
- Flags to simulate `else`
    
- Overpowered logic that fights edge cases (like huge repeated strings)
    

**The small but decisive shift**

- Stop thinking in terms of _checking_
    
- Start thinking in terms of _preserving an invariant_
    

> â€œAt every index, the window must represent exactly `p` â€” no more, no less.â€

Once you see it as **maintaining balance**, not **verifying equality**, most ideas collapse naturally:

- Encoding stops making sense
    
- Reconstruction becomes unnecessary
    
- Only _delta updates_ remain
    

Thatâ€™s the moment the solution space narrows.

---

### ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

**Why people mislabel this problem**

- It gets tagged as:
    
    - HashMap problem
        
    - Frequency array problem
        
    - Sliding window problem
        

Those labels focus attention on **tools**.

**Why that misleads here**

- The hard part isnâ€™t _counting_
    
- The hard part is _what must stay true while moving_
    

This problem is not about:

- Searching
    
- Matching
    
- Or recomputing
    

Itâ€™s about:

- Preserving a constraint while shifting one unit at a time
    

Once you think in invariants, the tool choice becomes obvious â€” almost boring.

---

### ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

Each major decision in the final code is not a rule â€” itâ€™s a consequence.

**Decision: fixed-size window**

- The problem demands exact length equality
    
- Variable windows immediately fight the constraint
    

**Decision: increment one, decrement one**

- Only two characters change per step
    
- Anything more is wasted effort
    

**Tempting alternative**

- Encode whole state
    
- Compare whole arrays every time
    
- Or â€œcompressâ€ information into integers
    

**Why it starts to feel leaky**

- You need flags to undo damage
    
- You invent reconstruction logic
    
- Edge cases explode (long identical strings exposed this)
    

The problem resists overpowered solutions.  
That resistance is a hint.

---

### ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why Your Artifacts Matter

**Flags (`flag`, `isAnagram`)**

- Prevents accidentally assuming success
    
- Common confusion: â€œdefault true should be fineâ€
    
- They reveal uncertainty about _what exactly proves correctness_
    

**Encode / Decode attempt**

- Prevents reinitializing arrays
    
- Common confusion: â€œmutation must be reversibleâ€
    
- Shows the moment where thinking drifted from invariants to bookkeeping
    

**Index confusion (`i-k`, `i-k+1`)**

- Prevents off-by-one blindness
    
- Common because window _end_ is easier to track than _start_
    
- Your comments show the exact point where the model wasnâ€™t anchored yet
    

These artifacts arenâ€™t mistakes â€” they are scaffolding.  
They mark where clarity was still forming.

**Insight compression**

Once you commit to:

> â€œOnly the delta mattersâ€

- Encoding
    
- Flags
    
- Reconstruction
    
- Complex conditionals
    

quietly stop making sense.

---

## ğŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ğŸ”µ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

Referring to your final code:

- Two arrays exist to represent **expectation vs reality**
    
- The first comparison establishes the invariant at index `0`
    
- Every iteration:
    
    - Removes one character
        
    - Adds one character
        
- The comparison loop exists only to confirm:
    
    - â€œDid my invariant survive this move?â€
        

If any part is reordered:

- The window stops representing what you think it does
    
- Off-by-one errors surface immediately
    

---

### ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

**Boolean vs int errors**

- Thinking: â€œ0/1 is simpler than true/falseâ€
    
- Java forces you to be explicit
    
- The language exposes ambiguity in the model
    

**StringIndexOutOfBounds**

- Thinking: â€œIf I slide until `n-k+1`, Iâ€™m safeâ€
    
- Reality: `charAt(i)` cares about `i < n`
    
- The bug reveals a mismatch between _window math_ and _string indexing_
    

**Failed large test (`aaaaâ€¦`)**

- Thinking: â€œEncoding compresses state safelyâ€
    
- Reality: repeated characters remove informational contrast
    
- The test exposes that the model depends on magnitude, not balance
    

Each bug is the problem correcting the mental model.

---

### ğŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

Your final structure does something important:

- Separates:
    
    - Setup
        
    - Invariant check
        
    - Sliding maintenance
        
- This makes it easy to answer:
    
    - â€œWhat does this line protect?â€
        

If flattened:

- Index logic becomes fragile
    
- Invariant reasoning dissolves into arithmetic
    

Structure here is not style â€” itâ€™s cognitive safety.

---

### ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

**The real constraint**

- Window size is fixed
    
- Alphabet size is constant (26)
    

**What looks important but isnâ€™t**

- Encoding tricks
    
- Reducing comparisons further
    
- Micro-optimizations
    

**Language reality**

- Java forces correctness in booleans and bounds
    
- Python might let mistakes slip silently
    

If alphabet size were large or dynamic:

- Youâ€™d track mismatch counts instead of full comparisons
    
- The thinking changes, not just the code
    

---

### ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern name**

- Fixed-Window Sliding Invariant
    

**Plain description**

- Maintain a condition that must stay true while moving one step at a time
    
- Update only what changes
    

**When this pattern is useful**

- Fixed-length substring problems
    
- Balance-based checks
    
- â€œExactly equalsâ€ conditions
    

**Different-looking problem where it applies**

- Permutation-in-string checks
    
- Fixed-length frequency matching
    

**Where it does _not_ apply**

- Variable-length windows
    
- Problems where the window grows or shrinks based on conditions
    

**Mental note**

> When the problem feels like comparison, stop checking.  
> This pattern wants maintenance, not verification.