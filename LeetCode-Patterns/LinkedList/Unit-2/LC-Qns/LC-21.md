# Drafts
## Draft1 : TLE
```java
/**

Â * Definition for singly-linked list.

Â * public class ListNode {

Â * Â  Â  int val;

Â * Â  Â  ListNode next;

Â * Â  Â  ListNode() {}

Â * Â  Â  ListNode(int val) { this.val = val; }

Â * Â  Â  ListNode(int val, ListNode next) { this.val = val; this.next = next; }

Â * }

Â */

class Solution {

Â  Â  public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

Â  Â  Â  Â  //Dummy Node optimisation

Â  Â  Â  Â  ListNode res = new ListNode(-1);

Â  Â  Â  Â  //Tail Node optimisation

Â  Â  Â  Â  ListNode tail = res;

Â  Â  Â  Â  //While comparable

Â  Â  Â  Â  while(list1 != null && list2 != null){

Â  Â  Â  Â  Â  Â  if(list1.val < list2.val){

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  else if(list1.val == list2.val){

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  else{

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  //While left over

Â  Â  Â  Â  while(list1 != null){

Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  while(list2 != null){

Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return res.next;

Â  Â  }

}
```

# Code
### Logical Solution
```java
/**

Â * Definition for singly-linked list.

Â * public class ListNode {

Â * Â  Â  int val;

Â * Â  Â  ListNode next;

Â * Â  Â  ListNode() {}

Â * Â  Â  ListNode(int val) { this.val = val; }

Â * Â  Â  ListNode(int val, ListNode next) { this.val = val; this.next = next; }

Â * }

Â */

class Solution {

Â  Â  public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

Â  Â  Â  Â  //Dummy Node optimisation

Â  Â  Â  Â  ListNode res = new ListNode(-1);

Â  Â  Â  Â  //Tail Node optimisation

Â  Â  Â  Â  ListNode tail = res;

Â  Â  Â  Â  //While comparable

Â  Â  Â  Â  while(list1 != null && list2 != null){

Â  Â  Â  Â  Â  Â  System.out.println(list1.val + " " + list2.val);

Â  Â  Â  Â  Â  Â  if (list1.val < list2.val) {

Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  Â  Â  tail = tail.next; Â 

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  else if (list1.val == list2.val) {

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  Â  Â  list1 = list1.next;
				
				//Order in which u updation matters wtf?
				//This is not deterministic behaviour
				//Compared to prev draft
  

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next; Â 

Â  Â  Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  else {

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next; Â 

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //tail = tail.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  //While left over

Â  Â  Â  Â  while(list1 != null){

Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  while(list2 != null){

Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return res.next;

Â  Â  }

}
```

### Optimised Solution
```java
/**

Â * Definition for singly-linked list.

Â * public class ListNode {

Â * Â  Â  int val;

Â * Â  Â  ListNode next;

Â * Â  Â  ListNode() {}

Â * Â  Â  ListNode(int val) { this.val = val; }

Â * Â  Â  ListNode(int val, ListNode next) { this.val = val; this.next = next; }

Â * }

Â */

class Solution {

Â  Â  public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

Â  Â  Â  Â  //Dummy Node optimisation

Â  Â  Â  Â  ListNode res = new ListNode(-1);

Â  Â  Â  Â  //Tail Node optimisation

Â  Â  Â  Â  ListNode tail = res;

Â  Â  Â  Â  //While comparable

Â  Â  Â  Â  while(list1 != null && list2 != null){

Â  Â  Â  Â  Â  Â  System.out.println(list1.val + " " + list2.val);

Â  Â  Â  Â  Â  Â  if (list1.val < list2.val) {

Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  Â  Â  tail = tail.next; Â 

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  else {

Â  Â  Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  Â  Â  Â  Â  tail = tail.next; Â 

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  //tail = tail.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  //While left over

Â  Â  Â  Â  while(list1 != null){

Â  Â  Â  Â  Â  Â  tail.next = list1;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list1 = list1.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  while(list2 != null){

Â  Â  Â  Â  Â  Â  tail.next = list2;

Â  Â  Â  Â  Â  Â  tail = tail.next;

Â  Â  Â  Â  Â  Â  list2 = list2.next;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return res.next;

Â  Â  }

}
```

## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ðŸ§  1ï¸âƒ£ Mental Model vs Memorization

- The instinctive way to approach this problem is to think:  
    _â€œI must explicitly handle every comparison case â€” less than, greater than, equal.â€_  
    That feels reasonable because merging _sounds_ like resolving all relational possibilities.
    
- Where this quietly breaks is that equality is not a special _state_ in this problem.  
    Sorted order already guarantees safety. Treating equality as exceptional adds branching without adding information.
    
- The small but decisive shift is this:  
    **You are not deciding values; you are advancing one pointer at a time while preserving order.**
    
- Once you see the task as _â€œwho advances next?â€_ instead of _â€œwhich case am I in?â€_, the solution space collapses:
    
    - Equality no longer needs ceremony.
        
    - Order is preserved by construction, not by logic.
        
    - The list itself enforces correctness.
        

> The realization is that merging is not comparison-heavy â€” itâ€™s pointer-progress-driven.

---

### ðŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Tool-Based)

- People rush to label this as:
    
    - â€œTwo pointersâ€
        
    - â€œLinked list manipulationâ€
        
    - â€œGreedy mergeâ€
        
- Those labels pull attention toward _tools_ instead of _invariants_.
    
- What must stay true is simpler:
    
    - The merged list is always sorted.
        
    - `tail` always points to the last confirmed correct node.
        
    - Exactly one input pointer moves per iteration.
        
- Categories mislead here because they encourage overthinking mechanics instead of preserving monotonic progress.
    

---

### ðŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Dummy node**
    
    - What the problem demands: a stable anchor that never changes meaning.
        
    - Tempting alternative: special-case the head.
        
    - Why it fights the problem: mental branching before the problem even starts.
        
- **Single attachment per iteration**
    
    - What the problem demands: linear, predictable progress.
        
    - Tempting alternative: attach both nodes on equality.
        
    - Why it leaks: you now depend on update _order_ rather than invariant preservation.
        
- **Let leftovers fall through**
    
    - What the problem demands: stop deciding once one list is exhausted.
        
    - Tempting alternative: keep comparing until both end.
        
    - Why itâ€™s awkward: comparison is meaningless once order is already guaranteed.
        

---

### ðŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts â€” Why _Your_ Artifacts Matter

- **The â€œTLEâ€ draft**
    
    - Prevents the confusion that complexity comes from loops.
        
    - The real issue was _branch explosion_, not time.
        
- **Inline comments about update order**
    
    - Prevents the common mistake of thinking pointer updates are commutative.
        
    - The exact moment this matters is the equality branch â€” where meaning depends on sequence.
        
- **The optimized version**
    
    - Prevents accidental overfitting to rare cases.
        
    - Shows that fewer decisions often mean _more_ correctness.
        

**Insight compression:**  
Once you trust monotonic pointer movement, extra logic starts to feel unnecessary â€” which is why simpler code suddenly feels safer.

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ðŸ”µ 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

- The `tail` pointer exists to represent _confirmed order_.  
    If it moves incorrectly or twice per iteration, the invariant collapses.
    
- The comparison block exists only to decide _which pointer advances_.  
    Nothing else.
    
- The leftover loops exist to explicitly state:  
    _â€œFrom here on, order is already correct â€” stop thinking.â€_
    

---

### ðŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Explicit equality handling**
    
    - Thinking behind it: â€œIf values are equal, I must preserve both now.â€
        
    - Why it feels reasonable: equality _sounds_ special.
        
    - How the problem exposes it: update order suddenly matters â€” a red flag.
        
- **Non-deterministic feeling**
    
    - Root cause: performing multiple semantic actions in one iteration.
        
    - The problem wants one unit of progress at a time.
        

These werenâ€™t mistakes â€” they were models that hadnâ€™t been simplified yet.

---

### ðŸŸ£ 7ï¸âƒ£ Code Structure Review (Cognitive Clarity)

- Separation into:
    
    - comparable phase
        
    - leftover phase  
        makes reasoning local.
        
- Flattening this logic would:
    
    - obscure termination conditions
        
    - mix â€œdecision-makingâ€ with â€œmechanical attachmentâ€
        

Structure here is about mental load, not syntax.

---

### ðŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs (Reality-Aware)

- The constraint that actually shapes the solution:
    
    - **Lists are already sorted.**
        
- Constraints that look important but arenâ€™t:
    
    - Value range
        
    - Duplicates
        
    - Stability (itâ€™s automatic here)
        
- Performance differences:
    
    - All versions are O(n + m).
        
    - Extra branching increases cognitive cost, not asymptotic cost.
        

If the lists were _not_ sorted, the entire mental model would change â€” this approach would no longer apply.

---

### ðŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern: Monotonic Pointer Merge**

- **Plain description:**  
    When multiple ordered streams exist, advance exactly one pointer at a time while maintaining a growing confirmed prefix.
    
- **When itâ€™s useful:**
    
    - Merging sorted lists
        
    - Interval merging
        
    - Streaming comparison problems
        
- **Different-looking problem where it applies:**  
    Merging two sorted arrays without extra space.
    
- **Where it does _not_ apply:**  
    Problems where future elements can invalidate earlier choices (e.g., backtracking, DP).
    

**Mental note:**  
_When the problem feels like â€œcompare everything,â€ stop â€” this pattern wants you to â€œadvance safely.â€_

## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ðŸ§  What _actually_ changed (and why that matters)

At a surface level, your **Draft (TLE)** and **Logical Solution (AC)** look identical:

- same dummy node
    
- same tail pointer
    
- same while conditions
    
- same comparisons
    

So the instinctive reaction is:

> â€œOrder shouldnâ€™t matter. These operations are equivalent.â€

That instinct is **false for pointer-based structures**.

The crucial mental mistake is assuming that **pointer updates commute** â€” that you can reorder them freely as long as all of them happen â€œwithin the same case.â€

They donâ€™t.

In a linked list, **every assignment mutates the shape of the structure immediately**.  
There is no rollback. No buffering. No atomicity.

So the real abstraction here is:

> You are not _adding nodes_.  
> You are **rewiring a live chain**, step by step, and every step changes what â€œnextâ€ means.

Once you see that, the behavior difference becomes inevitable.

---

### ðŸ”µ Why this problem punishes â€œlooks-equivalentâ€ logic

People classify this as:

- â€œmerge two sorted listsâ€
    
- â€œtwo pointersâ€
    

That framing encourages thinking in **values and cases**.

But the problem actually lives in **pointer invariants**:

What must _always_ be true:

- `tail.next` points to the **first unmerged node**
    
- `tail` always advances to a **node that is already in final position**
    
- `list1` and `list2` must **never be reused after advancing**
    

The moment you violate _any one_ of these, you donâ€™t get a crash â€” you get **cycles**.

And cycles â†’ infinite traversal â†’ TLE.

---

### ðŸŸ£ The specific conceptual trap you fell into

Your equality branch _tries to do two semantic actions in one iteration_:

```java
tail.next = list1;
tail = tail.next;
tail.next = list2;
tail = tail.next;
list1 = list1.next;
list2 = list2.next;
```

The thinking behind this is reasonable:

- â€œBoth nodes belong nextâ€
    
- â€œIâ€™ll just attach bothâ€
    

But the list does not think in _pairs_.  
It thinks in **edges**.

Each `tail.next = X` immediately:

- overwrites the previous `next`
    
- commits a structural decision
    
- changes what future `next` operations mean
    

So ordering becomes **structural**, not cosmetic.

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ðŸ”´ What actually caused the TLE (mechanically)

Letâ€™s isolate the exact failure mode.

In your **TLE draft**, this order appears:

```java
tail.next = list1;
tail = tail.next;

tail.next = list2;
tail = tail.next;

list1 = list1.next;
list2 = list2.next;
```

Notice the problem:

- `list1.next` is **still pointing to its old next**
    
- but `tail.next` has now been reassigned twice
    
- and `list1` and `list2` are advanced _after_ rewiring
    

This creates a window where:

- a node that is already attached
    
- still retains a pointer to a node that will later be reattached
    
- forming a **cycle** when leftovers are appended
    

No exception.  
No warning.  
Just a list that never ends.

That is why it TLEs.

---

### ðŸ”µ Why the â€œLogical Solutionâ€ passes

In the passing version, the order is:

```java
tail.next = list1;
tail = tail.next;
list1 = list1.next;

tail.next = list2;
tail = tail.next;
list2 = list2.next;
```

This single reordering enforces a hidden invariant:

> Once a node is attached, its original `next` is never used again.

That one property prevents cycles.

You didnâ€™t add logic.  
You removed **temporal ambiguity**.

---

### ðŸŸ£ Why this feels â€œnon-deterministicâ€ (but isnâ€™t)

You commented:

> â€œOrder in which u updation matters wtf?â€

Yes â€” and **it must**, because:

- linked lists are _stateful graphs_
    
- not value containers
    
- not functional data structures
    

This is deterministic behavior under **mutation semantics**.

What feels random is actually:

- a violated invariant that only shows up at runtime
    
- when traversal happens later
    

---

### ðŸ§© Pattern Extraction â€” the real lesson

**Pattern: Single-Advance Structural Mutation**

- **Rule:**  
    In pointer-based merges, **one semantic advancement per iteration**.
    
- **Plain meaning:**  
    Never attach two nodes before advancing the source pointer of the first.
    
- **When useful:**
    
    - Linked list merges
        
    - Tree rewiring
        
    - Graph construction from streams
        
- **When not applicable:**
    
    - Pure array merges
        
    - Immutable data structures
        

**Mental note to reuse later:**

> If you ever feel tempted to â€œattach two things at onceâ€ in a linked structure, stop.  
> The structure wants _time_, not cleverness.

Thatâ€™s the deep reason one version TLEs and the other passes.