# Draft
## Draft1: Didn't Work
```java
class Solution {

Â  Â  public ListNode removeElements(ListNode head, int val) {

Â  Â  Â  Â  ListNode dummy = new ListNode(-1);

Â  Â  Â  Â  dummy.next = head;

Â  Â  Â  Â  ListNode cur = dummy;

Â  Â  Â  Â  while(cur != null && cur.next != null){

Â  Â  Â  Â  Â  Â  if(cur.next.val == val){

Â  Â  Â  Â  Â  Â  Â  Â  cur.next = cur.next.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  cur = cur.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  return dummy.next;

Â  Â  }

}
```

# Code
```java
class Solution {

Â  Â  public ListNode removeElements(ListNode head, int val) {

Â  Â  Â  Â  ListNode dummy = new ListNode(-1);

Â  Â  Â  Â  dummy.next = head;

Â  Â  Â  Â  ListNode cur = dummy;

Â  Â  Â  Â  while(cur != null && cur.next != null){

Â  Â  Â  Â  Â  Â  while(cur != null && cur.next != null && cur.next.val == val){

Â  Â  Â  Â  Â  Â  Â  Â  cur.next = cur.next.next;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  cur = cur.next;

Â  Â  Â  Â  }

Â  Â  Â  Â  return dummy.next;

Â  Â  }

}
```

# Other's Codes
## Iterative
```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return head;

        ListNode dummy = new ListNode(0);
        dummy.next = head;


        ListNode temp = dummy;
        while(temp.next != null){
            if(temp.next.val == val){
                temp.next = temp.next.next;
            }
            else
                temp = temp.next; 
        }

        return dummy.next;
    }
}
```
## ðŸŸ¢ PART 1 â€” Abstraction & Thinking Layer

### ðŸ§  Why _this_ version feels clean (and actually is)

This version works not because itâ€™s shorter, but because it finally aligns **control flow** with **structural reality**.

The key mental shift compared to your earlier drafts is this:

> **Movement is conditional. Deletion is not.**

Earlier, you were implicitly assuming:

- â€œEvery loop iteration deserves a forward move.â€
    

This version rejects that assumption.

Instead, it adopts a sharper invariant:

> `temp` only moves forward when the link in front of it is _valid_.

That single idea removes the need for:

- nested loops
    
- special casing
    
- post-hoc fixes
    

So yes â€” itâ€™s cleaner, but more importantly, itâ€™s _truer_ to how linked lists behave.

---

### ðŸ”µ Why this avoids the earlier pitfall _without_ an inner loop

At first glance, it looks like magic:

- No nested `while`
    
- Yet consecutive deletions work
    

The reason is subtle but fundamental.

Compare the two mental models:

#### Old (failing) model

- â€œCheck â†’ maybe delete â†’ always moveâ€
    

#### New (working) model

- â€œCheck â†’ either delete **or** moveâ€
    

Deletion and movement are now **mutually exclusive**.

That exclusivity is what enforces correctness.

---

### ðŸŸ£ The decisive design choice

This line is the entire solution:

```java
else
    temp = temp.next;
```

This says:

- If deletion happens â†’ **stay**
    
- If no deletion â†’ **advance**
    

Which is exactly what the structure demands.

This is not a coding trick.  
Itâ€™s a statement of intent:

> â€œI will not leave this position until it is clean.â€

---

### ðŸŸ¡ Why the dummy node finally _feels_ sufficient

You used a dummy node before â€” but it didnâ€™t fully save you.

Why?

Because:

- Dummy nodes solve **where you start**
    
- They do not solve **when you move**
    

This version combines:

- dummy node â†’ structural uniformity
    
- conditional movement â†’ temporal correctness
    

Only together do they fully cover the problem.

---

## ðŸŸ  PART 2 â€” Technical & Algorithmic Post-Mortem

### ðŸ”µ What this loop is _actually_ enforcing

```java
while (temp.next != null) {
    if (temp.next.val == val) {
        temp.next = temp.next.next;
    } else {
        temp = temp.next;
    }
}
```

Hidden invariant:

> At loop entry, `temp.next` is the _only_ node under consideration.

And loop exit guarantees:

- Either that node is removed
    
- Or `temp` has moved past it knowing it is valid
    

No node is ever skipped.  
No node is ever checked twice unnecessarily.  
No node survives by accident.

---

### ðŸ”´ Why this succeeds where Draft1 failed

Draft1 violated this rule:

> â€œYou may not advance past a position that just changed.â€

This version obeys it strictly.

After a deletion:

- `temp` still points to the same node
    
- `temp.next` now points to the _new_ candidate
    
- That candidate is immediately rechecked
    

Thatâ€™s exactly what the nested `while` did before â€”  
but here itâ€™s encoded _structurally_, not syntactically.

---

### ðŸŸ£ Why this feels simpler to reason about

Because roles are separated cleanly:

- `temp` = _guardian of the boundary_
    
- `temp.next` = _candidate under inspection_
    

There is no moment where:

- you wonder whether a node was skipped
    
- you need to â€œmentally rewindâ€ pointer movement
    

Flattening works here **because responsibility is exclusive**.

---

### ðŸ”µ Constraints & Tradeoffs (Reality Check)

- Constraint that truly matters:
    
    - Multiple matching nodes can be adjacent
        
- Constraint that doesnâ€™t:
    
    - Head position (dummy removes it)
        
    - List size
        
    - Order of non-matching nodes
        

Time complexity remains O(n).  
This version doesnâ€™t do more work â€” it just refuses to move prematurely.

---

### ðŸ§© Pattern Extraction â€” the reusable insight

**Pattern: Conditional Advancement Traversal**

- **Plain description:**  
    In mutable linked structures, advance the pointer _only_ when no mutation occurred.
    
- **When it applies:**
    
    - Node deletion
        
    - Deduplication
        
    - Filtering runs of values
        
- **When it does _not_ apply:**
    
    - Read-only traversal
        
    - Array-based filtering
        
    - Immutable lists
        

**Mental note to reuse later:**

> If a step changes the structure, donâ€™t move.  
> If it doesnâ€™t, you may.

Thatâ€™s why this version is not just cleaner â€”  
itâ€™s _structurally honest_.