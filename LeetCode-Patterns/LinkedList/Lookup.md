## ðŸ“ PHASE 0 â€” CAPABILITY SKELETON (HARD GATE)

**Subject:** LeetCode Linked List Patterns

---

## ðŸ§± UNIT 1 â€” Linked List Fundamentals as a System

### Module 1.1 â€” Structural Primitives

**Submodule 1.1.1 â€” Node & Pointer Semantics**

- Singly vs doubly linked structure
    
- Ownership and reachability
    
- Pointer mutation vs value mutation
    
- Null as a structural boundary
    
- Head, tail, and sentinel roles
    

**Submodule 1.1.2 â€” Traversal as a State Machine**

- Cursor-based traversal
    
- Loop invariants in pointer walks
    
- Termination guarantees
    
- Off-by-one failure patterns
    
- Read-only vs mutating traversal
    

---

## ðŸ§± UNIT 2 â€” Pointer Manipulation Patterns

### Module 2.1 â€” Local Pointer Rewiring

**Submodule 2.1.1 â€” Insert & Delete Operations**

- Predecessor tracking
    
- Head mutation edge cases
    
- Constant-time guarantees
    
- Memory safety assumptions
    
- Structural integrity preservation
    

**Submodule 2.1.2 â€” Sublist Isolation**

- Boundary identification
    
- Detachâ€“operateâ€“reattach pattern
    
- Sentinel usage to simplify logic
    
- Preventing orphaned nodes
    

---

## ðŸ§± UNIT 3 â€” Two-Pointer Reasoning

### Module 3.1 â€” Relative Motion

**Submodule 3.1.1 â€” Fast & Slow Pointers**

- Differential pointer speeds
    
- Phase-based reasoning
    
- Cycle interaction mechanics
    
- Mathematical convergence logic
    
- Failure cases under malformed lists
    

**Submodule 3.1.2 â€” Offset Pointers**

- Fixed-distance invariants
    
- Window maintenance in linear structures
    
- One-pass guarantees
    
- Head-alignment techniques
    

---

## ðŸ§± UNIT 4 â€” Reversal as a Primitive Operation

### Module 4.1 â€” In-Place Reversal Mechanics

**Submodule 4.1.1 â€” Full List Reversal**

- Iterative pointer flipping
    
- State transition ordering
    
- Head reassignment correctness
    
- Loss-of-reference hazards
    

**Submodule 4.1.2 â€” Partial Reversal**

- Segment boundary control
    
- Reversal within constraints
    
- Reconnection correctness
    
- Nested reversal pitfalls
    

---

## ðŸ§± UNIT 5 â€” Structural Detection & Integrity

### Module 5.1 â€” Structural Anomalies

**Submodule 5.1.1 â€” Cycle Detection**

- Existence vs entry point detection
    
- Proof of inevitability
    
- Constant-space guarantees
    
- Non-standard cycle shapes
    

**Submodule 5.1.2 â€” Intersection Detection**

- Shared tail reasoning
    
- Length normalization
    
- Pointer synchronization
    
- False-positive prevention
    

---

## ðŸ§± UNIT 6 â€” List Transformation Patterns

### Module 6.1 â€” Shape-Changing Operations

**Submodule 6.1.1 â€” Partitioning & Reordering**

- Stable vs unstable rearrangement
    
- Multi-list decomposition
    
- Reassembly correctness
    
- Data preservation guarantees
    

**Submodule 6.1.2 â€” Merging Strategies**

- Sorted merge invariants
    
- K-list merge abstractions
    
- Trade-offs: heap vs pairwise
    
- Structural cost analysis
    

---

## ðŸ§± UNIT 7 â€” Recursive & Hybrid Techniques

### Module 7.1 â€” Recursion with Pointers

**Submodule 7.1.1 â€” Recursive Traversal & Reversal**

- Call stack as implicit state
    
- Base case correctness
    
- Stack depth constraints
    
- Iterative equivalence reasoning
    

---

## ðŸ§± UNIT 8 â€” Pattern Synthesis & Interview Abstractions

### Module 8.1 â€” Pattern Recognition

**Submodule 8.1.1 â€” Problem Decomposition**

- Pattern-to-problem mapping
    
- Anti-pattern identification
    
- Constraint-driven strategy choice
    
- Timeâ€“space trade-off articulation
    

---

> âœ… Skeleton represents full capability map â€” nothing omitted

ðŸ‘‰ **Approve / Modify / Reorder / Add / Remove**

â›” Teaching will not proceed without explicit approval.