## Code
## ~~Draft 1: Problem with Going Upwards~~
```java
/**

Â * Definition for a binary tree node.

Â * public class TreeNode {

Â * Â  Â  int val;

Â * Â  Â  TreeNode left;

Â * Â  Â  TreeNode right;

Â * Â  Â  TreeNode(int x) { val = x; }

Â * }

Â */

class Solution {

Â  Â  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

Â  Â  Â  Â  if(root == null) return null;

Â  Â  Â  Â  TreeNode Left = lowestCommonAncestor(root.left, p, q);

Â  Â  Â  Â  TreeNode Right = lowestCommonAncestor(root.right, p, q);

  

Â  Â  Â  Â  if(Left == p && Right == q || Left == q && Right == p) {

Â  Â  Â  Â  Â  Â  System.out.println(root.val);

Â  Â  Â  Â  Â  Â  return root;

Â  Â  Â  Â  }

Â  Â  Â  Â  if(root == p && (Left == q || Right == q)){

Â  Â  Â  Â  Â  Â  System.out.println(root.val);

Â  Â  Â  Â  Â  Â  return root;

Â  Â  Â  Â  }

Â  Â  Â  Â  if(root == q && (Left == p || Right == p)) {

Â  Â  Â  Â  Â  Â  System.out.println(root.val);

Â  Â  Â  Â  Â  Â  return root;

Â  Â  Â  Â  }

Â  Â  Â  Â  //Idk how to translate watever trace

Â  Â  Â  Â  //I wrote in my notebook to recursion

Â  Â  Â  Â  //Lol I have to make generic solutions somehow

Â  Â  Â  Â  //That works everywhere and constrain base cases

Â  Â  Â  Â  //Thinking is hard

  

Â  Â  Â  Â  //Edge case wat if p and q are the same?

Â  Â  Â  Â  //Cool constraints handle tht

Â  Â  Â  Â  if(root == p || root == q) return root;

Â  Â  Â  Â  if(Left == p || Left == q) return Left;

Â  Â  Â  Â  if(Right == p || Right == q) return Right;

  

Â  Â  Â  Â  //IDK Man i give up lol fked up

Â  Â  Â  Â  //I manually traced it i see while going up

Â  Â  Â  Â  //Even when match spotted I make it die off

Â  Â  Â  Â  //So this code has tht going up error

Â  Â  Â  Â  //Somehow i have to force my way up somehow

Â  Â  Â  Â  return null;

  

Â  Â  }

}
```
## Draft 2: I got stuck with External Class
```java
/**

Â * Definition for a binary tree node.

Â * public class TreeNode {

Â * Â  Â  int val;

Â * Â  Â  TreeNode left;

Â * Â  Â  TreeNode right;

Â * Â  Â  TreeNode(int x) { val = x; }

Â * }

Â */

class Solution {

  

Â  Â  static class object{

Â  Â  Â  Â  TreeNode ancestor; //Need public?? idk

Â  Â  Â  Â  TreeNode node; //Idk why i put it here

Â  Â  Â  Â  boolean found;

  

Â  Â  Â  Â  object(){

Â  Â  Â  Â  Â  Â  ancestor = null;

Â  Â  Â  Â  Â  Â  found = false;

Â  Â  Â  Â  Â  Â  node = null;

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

Â  Â  Â  Â  return null;

Â  Â  }

  

Â  Â  //Does status boolean help ?

Â  Â  object helper(TreeNode root, TreeNode p, TreeNode q){

Â  Â  Â  Â  if(root == null) {

Â  Â  Â  Â  Â  Â  return new object();

Â  Â  Â  Â  }

Â  Â  Â  Â  object Left = helper(root.left, p, q);

Â  Â  Â  Â  object Right = helper(root.right, p, q);

Â  Â  Â  Â  if(Left.found == true) return Left;

Â  Â  Â  Â  if(Right.found == true) return Right;

  
  
  

Â  Â  Â  Â  //Ancestor found if Left Â 

Â  Â  }

}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  
## ğŸŸ¢ **PART 1 â€” Abstraction & Thinking Layer**  
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

### 1ï¸âƒ£ Mental Model vs Memorization

The instinct most people have with LCA is very understandable:

- â€œFind `p` somewhereâ€
    
- â€œFind `q` somewhereâ€
    
- â€œFigure out where their paths meetâ€
    

This feels reasonable because thatâ€™s how _humans_ think about trees on paper: paths, directions, ancestry.

But notice where this quietly goes wrong.

The moment you think in terms of **paths**, your brain starts caring about:

- where you came from,
    
- how you go back up,
    
- whether a result should â€œoverrideâ€ another.
    

Thatâ€™s exactly what happened in your Draft 1: once something was found, you kept worrying about whether it would survive while going up.

The small but crucial shift is this:

> Donâ€™t think of recursion as â€œwalking the treeâ€.  
> Think of it as **each subtree sending a summary upward**.

Each subtree doesnâ€™t explain _how_ it found something.  
It just reports **what it knows**.

Thatâ€™s why the line

```java
if (root == p || root == q) return root;
```

feels magical at first.
[[lc-236-assumptions-constraints]]

Itâ€™s not magic. Itâ€™s a **summary rule**:

- â€œFrom here downward, I can already confirm one of the targets exists.â€
    

Once you accept that, you stop worrying about â€œlower results being ignoredâ€.  
They arenâ€™t ignored â€” theyâ€™re **subsumed** by a stronger fact.

And once that clicks, the rest of the logic stops feeling like clever casework and starts feeling like bookkeeping.

---

### ğŸ”µ 2ï¸âƒ£ Problem Classification (Conceptual, Not Label-Based)

People often want to label this early:

- â€œTree problemâ€
    
- â€œDFSâ€
    
- â€œDivide and conquerâ€
    

Those labels arenâ€™t wrong, but they pull attention toward **process** instead of **meaning**.

The problem isnâ€™t asking:

- â€œHow do I traverse?â€
    
- â€œWhich order do I visit nodes?â€
    

Itâ€™s really asking:

- â€œWhat information must survive when recursion unwinds?â€
    

That reframing matters because:

- traversal order doesnâ€™t change the answer,
    
- but **what you choose to return** absolutely does.
    

Once you focus on what must remain true when control returns to the parent, algorithm labels become background noise.

---

### ğŸŸ£ 3ï¸âƒ£ Design Decisions and Their Necessity

- **Decision: short-circuit when `root == p || root == q`**
    
    - What the problem demands:  
        If one target is found at this node, that fact should dominate anything below.
        
    - Tempting alternative:  
        â€œLet me still check children to be safe.â€
        
    - Why that breaks down:  
        You end up second-guessing a fact that is already complete.
        
- **Decision: check `Left` and `Right` together**
    
    - What the problem demands:  
        LCA is a _merge event_, not a discovery event.
        
    - Tempting alternative:  
        Return as soon as you see one side succeed.
        
    - Why that feels wrong later:  
        You accidentally prevent the parent from seeing both sides at once.
        
- **Decision: return only one thing**
    
    - What the problem demands:  
        Parents should reason using _outputs_, not internal states.
        
    - Tempting alternative:  
        Flags, wrapper classes, â€œfoundâ€ booleans.
        
    - Why that starts to feel awkward:  
        Youâ€™re compensating for unclear meaning, not adding power.
        

---

### ğŸŸ¡ 4ï¸âƒ£ Reasoning Artifacts and How They Help You Avoid Mistakes

- **Mental note: â€œWhat can this function legally return?â€**
    
    - Prevents: case explosion.
        
    - Why the confusion is common:  
        Trees feel like they require many states.
        
    - Concrete help here:  
        You realize `TreeNode` already encodes all necessary states.
        
- **Mental picture: two arrows coming up from children**
    
    - Prevents: early returns.
        
    - Why it helps:  
        It reminds you that LCA only appears when _both_ arrows exist.
        
- **Invariant scribble: â€œParent only reads child summariesâ€**
    
    - Prevents: re-checking or overriding results.
        
    - Concrete moment:  
        Stops you from worrying that â€œlower results are being disregardedâ€.
        

**Insight Compression:**  
Once you start thinking in terms of subtree summaries instead of paths, a whole set of conditional-heavy approaches quietly stops making sense â€” which is why the solution narrows down so quickly.

---

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  
## ğŸŸ  **PART 2 â€” Technical & Algorithmic Post-Mortem**  
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

### 5ï¸âƒ£ Algorithm Walkthrough (With Intent)

- **Base return (`null`)**
    
    - Exists to say: â€œnothing useful below meâ€.
        
    - Without it, parents canâ€™t distinguish absence from presence.
        
- **Immediate return on `p` or `q`**
    
    - Exists to preserve a strong fact early.
        
    - If removed or delayed, you start compensating with extra checks later.
        
- **Left + Right recursion**
    
    - Exists to collect independent summaries.
        
    - The order doesnâ€™t matter â€” the combination does.
        
- **`Left != null && Right != null`**
    
    - Exists to detect the exact moment both targets are confirmed.
        
    - If this check is missing, LCA never materializes.
        

---

### ğŸ”´ 6ï¸âƒ£ Error & Bug Analysis (Thinking-Level)

- **Bug: Returning too early**
    
    - Thought behind it: â€œI already found something useful.â€
        
    - Why it feels reasonable:  
        In linear recursion, early success is often correct.
        
    - How the problem exposes it:  
        Tree problems require _coordination_ between branches.
        
- **Bug: Overchecking `root == p` alongside children**
    
    - Thought behind it: â€œWhat if this interferes?â€
        
    - Why it feels reasonable:  
        Youâ€™re afraid of losing information.
        
    - Whatâ€™s actually happening:  
        You havenâ€™t yet trusted the return contract.
        

---

### ğŸŸ£ 7ï¸âƒ£ Code Structure Review

This structure helps because:

- each return has a single, clear meaning,
    
- parents never peek into grandchildren,
    
- no state is stored outside the call stack.
    

If flattened:

- youâ€™d have to remember _why_ a value was returned,
    
- mental load increases,
    
- bugs stop being local.
    

The current structure externalizes the thinking into the function shape itself.

---

### ğŸ”µ 8ï¸âƒ£ Constraints & Tradeoffs

- **Real constraint shaping the solution**
    
    - Nodes are unique and comparisons are by identity.
        
    - This allows a single return value to encode multiple states.
        
- **Constraints that look important but arenâ€™t**
    
    - Tree balance
        
    - Traversal order
        
    - Depth
        
- **If constraints changed**
    
    - If duplicates existed or references werenâ€™t given, youâ€™d need a different return contract.
        
    - The thinking would change before the code does.
        

---

### ğŸ§© 9ï¸âƒ£ Pattern Extraction (Reusable Thinking)

**Pattern (plain language):**  
â€œLet each recursive call report the strongest fact it can prove, and let the parent only merge those reports.â€

**Useful when:**

- answers emerge from combining independent sub-results,
    
- the result is a _node_, not a number.
    

**Different-looking example where it applies:**

- Finding the deepest common subtree satisfying a condition.
    

**Case where it doesnâ€™t:**

- Problems where order or sequence matters (e.g., path construction).
    

**Reusable mental note:**

> â€œIf Iâ€™m adding flags, I probably havenâ€™t decided what this function is allowed to say yet.â€